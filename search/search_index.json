{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Fixie Developer Portal \ud83e\udd8a Fixie is a platform for building applications using large language models. With Fixie, you can create apps that communicate in natural language with one or more agents that access individual APIs or sources of data, such as GitHub, Google Calendar, or a database. Access the Fixie web interface at app.fixie.ai . The Fixie SDK allows you to connect your applications to the Fixie platform, either as a client or by building custom agents that plug into the platform. Learn more about Fixie at https://fixie.ai . Fixie Developer Preview : Fixie is currently available as a Developer Preview. During this time, Fixie is free to use; however, there is a limit on the number of queries per user per day. Please see Fixie Developer Preview for more information. Need help? : The best way to contact us and get support is to join our Discord server . Getting Started Verify access to app.fixie.ai with your Google or GitHub email. Install the Fixie CLI using pip install fixieai and run fixie auth to ensure successful authentication. Fork the examples repo . Demo an agent Choose any example agent cd into the directory Run fixie agent deploy You can now test the agent through the following methods: * Run fixie console -a username/agent_name and input a test query. * Run fixie console and then @ your specific agent (e.g., @username/agent_name this is the query ). * Talk to deployed agents directly at app.fixie.ai . * Interact with the agent programmatically: py import fixieai response = fixieai.query(\"How many countries start with the letter R ?\") print(response) For local development and testing, run your agent locally with fixie agent serve . This will create a tunnel to your local machine so that the Fixie platform can communicate with your agent. After running serve, open a new terminal window and talk to the agent via fixie console . Agent Examples Agents are at the heart of the Fixie ecosystem, and we make it easy to build and contribute your own. Start by scaffolding a default agent with fixie init . For more examples, check out Building Fixie agents and our examples repo . Documentation Explore the links below for more information on getting started with Fixie. Tutorials Fixie Architecture Overview agent Quickstart Building Fixie agents agent Protocol Reference Fixie CLI Reference Python Client API Python agent API Fixie GraphQL API Reference","title":"Introduction"},{"location":"#fixie-developer-portal","text":"Fixie is a platform for building applications using large language models. With Fixie, you can create apps that communicate in natural language with one or more agents that access individual APIs or sources of data, such as GitHub, Google Calendar, or a database. Access the Fixie web interface at app.fixie.ai . The Fixie SDK allows you to connect your applications to the Fixie platform, either as a client or by building custom agents that plug into the platform. Learn more about Fixie at https://fixie.ai . Fixie Developer Preview : Fixie is currently available as a Developer Preview. During this time, Fixie is free to use; however, there is a limit on the number of queries per user per day. Please see Fixie Developer Preview for more information. Need help? : The best way to contact us and get support is to join our Discord server .","title":"Fixie Developer Portal \ud83e\udd8a"},{"location":"#getting-started","text":"Verify access to app.fixie.ai with your Google or GitHub email. Install the Fixie CLI using pip install fixieai and run fixie auth to ensure successful authentication. Fork the examples repo .","title":"Getting Started"},{"location":"#demo-an-agent","text":"Choose any example agent cd into the directory Run fixie agent deploy You can now test the agent through the following methods: * Run fixie console -a username/agent_name and input a test query. * Run fixie console and then @ your specific agent (e.g., @username/agent_name this is the query ). * Talk to deployed agents directly at app.fixie.ai . * Interact with the agent programmatically: py import fixieai response = fixieai.query(\"How many countries start with the letter R ?\") print(response) For local development and testing, run your agent locally with fixie agent serve . This will create a tunnel to your local machine so that the Fixie platform can communicate with your agent. After running serve, open a new terminal window and talk to the agent via fixie console .","title":"Demo an agent"},{"location":"#agent-examples","text":"Agents are at the heart of the Fixie ecosystem, and we make it easy to build and contribute your own. Start by scaffolding a default agent with fixie init . For more examples, check out Building Fixie agents and our examples repo .","title":"Agent Examples"},{"location":"#documentation","text":"Explore the links below for more information on getting started with Fixie.","title":"Documentation"},{"location":"#tutorials","text":"Fixie Architecture Overview agent Quickstart Building Fixie agents agent Protocol","title":"Tutorials"},{"location":"#reference","text":"Fixie CLI Reference Python Client API Python agent API Fixie GraphQL API Reference","title":"Reference"},{"location":"agent-protocol/","text":"Fixie Agent Protocol Fixie agents can be implemented in any programming language. The Fixie Python Agent API provides a Python SDK that simplifies the implementation of agents in Python. However, it is possible to implement Fixie agents in any programming language, as long as the agent code conforms to the following protocol. A Fixie agent is a program that accepts HTTP requests of two types: An HTTP GET request to the / endpoint, which returns a list of few-shot examples that the agent supports. An HTTP POST request to the /FUNC endpoint, which returns the result of calling the function FUNC with the parameters specified in the request. Agents can support multiple functions. Few-shot examples Upon receiving an HTTP GET request to the / endpoint, the agent must return a list of few-shot examples that it supports. The few-shot examples are used to provide examples to the underlying Large Language Model, such as GPT-4, as well as to provide the Fixie Platform information on what kinds of queries this agent can support. The few-shot examples are returned as a JSON object with the following format: { \"base_prompt\" : \"The base prompt for the few-shot examples.\" , \"few_shots\" : [ \"The first few-shot example.\" , \"The second few-shot example.\" , \"The third few-shot example.\" ] } Each few-shot example consists of one or more lines, separated by a newline character ( \\n ). The first line of each example must be a sample query, which must start with the prefix Q: . The final line of the few-shot example must be the corresponding answer, which must start with the prefix A: . The few-shot example may contain any number of lines in between the query and answer, representing intermediate outputs from the Large Language Model and responses to the LLM from external functions. Here a single few-shot example: Q : Generate a random number between 0 and 19. Ask Func [ genrand ] : 0 , 19 Func [ genrand ] says : 17 A : The random number is 17. In this example, the first line represents a sample query that the agent can support. The second line is the LLM's response to receiving this query, which in this case indicates that the Function genrand should be invoked with the input string 0, 19 . The third line is the expected response from the Function genrand , and the final line is the answer to the query. Using the Fixie Python SDK, the values of the base_prompt and few_shots fields are specified by setting the values of the BASE_PROMPT and FEW_SHOTS variables in the agent code, respectively. Function invocation Upon receiving an HTTP POST request to the /FUNC endpoint, the agent must return the result of calling the agent function FUNC with the parameters specified in the body of the HTTP POST request. The body of the POST request will be in the following format: { \"message\" : { \"text\" : \"Argument to function call\" , } } The agent should invoke the function FUNC , passing in the contents of the JSON object message as the argument to the function call. The result of the function call should be returned as the value of the result field in the response to the HTTP POST request. The response to the HTTP POST request should be a JSON object in the format: { \"message\" : { \"text\" : \"Response to function call\" , } } Using the Fixie Python SDK, implementing an agent function is done using the @fixieai.CodeShotAgent.register_func decorator. The decorator takes a single argument, which is the function to be registered. The function must take a single argument, which contains the JSON message object from the HTTP POST request. The function should return a string, which will be the value of the text field in the response message returned by the agent. See python-agent-api.md for more information on the Fixie Python agent API, and agent-quickstart.md for a quickstart guide on how to implement agents in Fixie.","title":"Agent Protocol"},{"location":"agent-protocol/#fixie-agent-protocol","text":"Fixie agents can be implemented in any programming language. The Fixie Python Agent API provides a Python SDK that simplifies the implementation of agents in Python. However, it is possible to implement Fixie agents in any programming language, as long as the agent code conforms to the following protocol. A Fixie agent is a program that accepts HTTP requests of two types: An HTTP GET request to the / endpoint, which returns a list of few-shot examples that the agent supports. An HTTP POST request to the /FUNC endpoint, which returns the result of calling the function FUNC with the parameters specified in the request. Agents can support multiple functions.","title":"Fixie Agent Protocol"},{"location":"agent-protocol/#few-shot-examples","text":"Upon receiving an HTTP GET request to the / endpoint, the agent must return a list of few-shot examples that it supports. The few-shot examples are used to provide examples to the underlying Large Language Model, such as GPT-4, as well as to provide the Fixie Platform information on what kinds of queries this agent can support. The few-shot examples are returned as a JSON object with the following format: { \"base_prompt\" : \"The base prompt for the few-shot examples.\" , \"few_shots\" : [ \"The first few-shot example.\" , \"The second few-shot example.\" , \"The third few-shot example.\" ] } Each few-shot example consists of one or more lines, separated by a newline character ( \\n ). The first line of each example must be a sample query, which must start with the prefix Q: . The final line of the few-shot example must be the corresponding answer, which must start with the prefix A: . The few-shot example may contain any number of lines in between the query and answer, representing intermediate outputs from the Large Language Model and responses to the LLM from external functions. Here a single few-shot example: Q : Generate a random number between 0 and 19. Ask Func [ genrand ] : 0 , 19 Func [ genrand ] says : 17 A : The random number is 17. In this example, the first line represents a sample query that the agent can support. The second line is the LLM's response to receiving this query, which in this case indicates that the Function genrand should be invoked with the input string 0, 19 . The third line is the expected response from the Function genrand , and the final line is the answer to the query. Using the Fixie Python SDK, the values of the base_prompt and few_shots fields are specified by setting the values of the BASE_PROMPT and FEW_SHOTS variables in the agent code, respectively.","title":"Few-shot examples"},{"location":"agent-protocol/#function-invocation","text":"Upon receiving an HTTP POST request to the /FUNC endpoint, the agent must return the result of calling the agent function FUNC with the parameters specified in the body of the HTTP POST request. The body of the POST request will be in the following format: { \"message\" : { \"text\" : \"Argument to function call\" , } } The agent should invoke the function FUNC , passing in the contents of the JSON object message as the argument to the function call. The result of the function call should be returned as the value of the result field in the response to the HTTP POST request. The response to the HTTP POST request should be a JSON object in the format: { \"message\" : { \"text\" : \"Response to function call\" , } } Using the Fixie Python SDK, implementing an agent function is done using the @fixieai.CodeShotAgent.register_func decorator. The decorator takes a single argument, which is the function to be registered. The function must take a single argument, which contains the JSON message object from the HTTP POST request. The function should return a string, which will be the value of the text field in the response message returned by the agent. See python-agent-api.md for more information on the Fixie Python agent API, and agent-quickstart.md for a quickstart guide on how to implement agents in Fixie.","title":"Function invocation"},{"location":"agent-quickstart/","text":"Fixie Agent Quickstart Fixie allows you to extend the capabilities of the Fixie Platform by building your own agents , which are specialized software components that combine a set of few-shot examples with code to invoke external systems. We call this combination of few-shots coupled with code Code Shots (clever, eh?). You can implement Fixie agents in any programming language. However, the Fixie SDK currently provides bindings only for Python. See the Agent Protocol for details on implementing your own agent in a language other than Python. We'll be shipping bindings for other languages soon! Create a Fixie Agent The first step is to create a new agent directory using the fixie init command: $ mkdir myagent $ cd myagent $ fixie init Handle [ myagent ] : Description [] : A simple test agent. Entry point [ main:agent ] : More info url [] : fixie init will prompt you to enter some information about your agent. Handle : the unique identifier used to identify the agent in the Fixie Platform. Description : an optional plain-text description of the agent's abilities. Entry point : the name of the Python module that contains the agent code, which we will create in the next step below. More info url : an optional URL that you can provide, which offers more information about the agent. This can point to any website. Public : flag indicates whether the agent should be publicly visible in the Fixie Platform for other users. If you set this to True , anyone can use your agent in their own applications. Running fixie init will create the file agent.yaml in the current directory, containing metadata on the agent. Write the Agent Code Next, paste the following code into a file called main.py : import random import fixieai BASE_PROMPT = \"I am a simple agent that generates a random number between two given values.\" FEW_SHOTS = \"\"\" Q: Generate a random number between 0 and 19. Ask Func[genrand]: 0, 19 Func[genrand] says: 17 A: The random number is 17. Q: Generate a random value from 5 to 10, inclusive. Ask Func[genrand]: 5, 10 Func[genrand] says: 8 A: The random number is 8. \"\"\" agent = fixieai . CodeShotAgent ( BASE_PROMPT , FEW_SHOTS ) @agent . register_func () def genrand ( query : fixieai . Message ) -> str : low , high = query . text . replace ( \" \" , \"\" ) . split ( \",\" ) return str ( random . randint ( int ( low ), int ( high ))) The code consists of two main parts: BASE_PROMPT and FEW_SHOTS : These are the few-shot examples that define the agent's purpose and behavior. The few-shots are used to provide examples to the underlying Large Language Model, such as GPT-4, as well as to provide the Fixie Platform information on what kinds of queries this agent can support. Code snippets : These are the functions that are invoked by the Code Shots. The code snippets are registered with the agent using the register_func decorator. In the FEW_SHOTS string, the Func[genrand] keyword indicates that the function genrand should be invoked when the output of the underlying LLM starts with this string. The values following Ask Func[genrand]: are passed to the function as the query.text parameter. In this case, the function parses out the values and returns a random number between those two values. Test Your Agent To test your agent, you have two options: Run it on your local machine using the fixie agent serve command. This allows you to see the debugging logs of your agent directly in your console. Deploy it to the Fixie platform using the fixie agent deploy command. Whichever option you choose, you can still use the Fixie Platform (e.g. REST API, GraphQL API, or app.fixie.ai web app) to access your agent. $ fixie agent serve Opening tunnel to 0 .0.0.0:8181 via localhost.run. \ud83e\udd8a Agent mdw/myagent running locally on 0 .0.0.0:8181, served via https://a94073298907cd.lhr.life You can access your agent via https://app.fixie.ai/agents/mdw/myagent or ` fixie console --agent mdw/myagent ` . When running fixie agent serve , a tunnel is set up that allows the agent, running on your local machine, to be accessed from the Fixie Platform . The URL of the tunnel is printed on the console. If you quit the fixie agent serve process (e.g., by pressing Ctrl-C), the tunnel is torn down and your agent is no longer accessible. You can now use fixie console or fixie console --agent <username>/<agent_name> to send a message to your agent directly: $ fixie console Welcome to Fixie! Connected to: https://app.fixie.ai/sessions/stormy-luxuriant-ferryboat fixie \ud83e\udd8a\u276f @mdw/myagent Generate a random number between 10 and 50 @user: @mdw/myagent Generate a random number between 10 and 50 @myagent: Generate a random number between 10 and 50 @myagent: Ask Func: 10 , 50 @myagent: Func says: 48 @myagent: The random number is 48 . 1 \u276f The random number is 48 . In the fixie agent serve window, you should also see debugging output showing that your agent code was invoked with a POST request to the /genrand endpoint. Deploy Your Agent Agents can be deployed on any web server that supports Python. Alternatively, you can deploy your agent directly to the Fixie platform, which will handle hosting the agent functions in the cloud. To deploy your agent, simply run fixie agent deploy : $ fixie agent deploy \u2705 Deploying... \u2705 Refreshing... This process takes about a minute to complete. Once deployed, you can use your agent via the Fixie Web UI or the fixie console tool. Agent REST API Once deployed (via fixie agent serve or fixie agent deploy ), your agent can also be invoked via a REST API, using a POST request to the endpoint /api/agents/<username>/<agent_handle> . For example, the fixie/calc agent can be invoked as follows: $ export FIXIE_API_KEY = <Your Fixie API key> $ curl https://app.fixie.ai/api/agents/fixie/calc \\ -H \"Authorization: Bearer ${ FIXIE_API_TOKEN } \" \\ -H \"Content-Type: application/json\" \\ -d '{ \"message\": {\"text\": \"What is 999 + 222?\" }}' Your Fixie API key can be obtained from your user profile page. Fixie GraphQL API Apart from the Agent REST API described above, the Fixie GraphQL API is a more rich and powerful API surface for interacting with Fixie, including creating agents, sending messages, and more. For more information, see the Fixie GraphQL API documentation . Implementing Agents without Python Refer to the Agent Protocol documentation for details on implementing an agent in a language other than Python. For complete information on the Fixie Agent API, see Agent API .","title":"Agent QuickStart"},{"location":"agent-quickstart/#fixie-agent-quickstart","text":"Fixie allows you to extend the capabilities of the Fixie Platform by building your own agents , which are specialized software components that combine a set of few-shot examples with code to invoke external systems. We call this combination of few-shots coupled with code Code Shots (clever, eh?). You can implement Fixie agents in any programming language. However, the Fixie SDK currently provides bindings only for Python. See the Agent Protocol for details on implementing your own agent in a language other than Python. We'll be shipping bindings for other languages soon!","title":"Fixie Agent Quickstart"},{"location":"agent-quickstart/#create-a-fixie-agent","text":"The first step is to create a new agent directory using the fixie init command: $ mkdir myagent $ cd myagent $ fixie init Handle [ myagent ] : Description [] : A simple test agent. Entry point [ main:agent ] : More info url [] : fixie init will prompt you to enter some information about your agent. Handle : the unique identifier used to identify the agent in the Fixie Platform. Description : an optional plain-text description of the agent's abilities. Entry point : the name of the Python module that contains the agent code, which we will create in the next step below. More info url : an optional URL that you can provide, which offers more information about the agent. This can point to any website. Public : flag indicates whether the agent should be publicly visible in the Fixie Platform for other users. If you set this to True , anyone can use your agent in their own applications. Running fixie init will create the file agent.yaml in the current directory, containing metadata on the agent.","title":"Create a Fixie Agent"},{"location":"agent-quickstart/#write-the-agent-code","text":"Next, paste the following code into a file called main.py : import random import fixieai BASE_PROMPT = \"I am a simple agent that generates a random number between two given values.\" FEW_SHOTS = \"\"\" Q: Generate a random number between 0 and 19. Ask Func[genrand]: 0, 19 Func[genrand] says: 17 A: The random number is 17. Q: Generate a random value from 5 to 10, inclusive. Ask Func[genrand]: 5, 10 Func[genrand] says: 8 A: The random number is 8. \"\"\" agent = fixieai . CodeShotAgent ( BASE_PROMPT , FEW_SHOTS ) @agent . register_func () def genrand ( query : fixieai . Message ) -> str : low , high = query . text . replace ( \" \" , \"\" ) . split ( \",\" ) return str ( random . randint ( int ( low ), int ( high ))) The code consists of two main parts: BASE_PROMPT and FEW_SHOTS : These are the few-shot examples that define the agent's purpose and behavior. The few-shots are used to provide examples to the underlying Large Language Model, such as GPT-4, as well as to provide the Fixie Platform information on what kinds of queries this agent can support. Code snippets : These are the functions that are invoked by the Code Shots. The code snippets are registered with the agent using the register_func decorator. In the FEW_SHOTS string, the Func[genrand] keyword indicates that the function genrand should be invoked when the output of the underlying LLM starts with this string. The values following Ask Func[genrand]: are passed to the function as the query.text parameter. In this case, the function parses out the values and returns a random number between those two values.","title":"Write the Agent Code"},{"location":"agent-quickstart/#test-your-agent","text":"To test your agent, you have two options: Run it on your local machine using the fixie agent serve command. This allows you to see the debugging logs of your agent directly in your console. Deploy it to the Fixie platform using the fixie agent deploy command. Whichever option you choose, you can still use the Fixie Platform (e.g. REST API, GraphQL API, or app.fixie.ai web app) to access your agent. $ fixie agent serve Opening tunnel to 0 .0.0.0:8181 via localhost.run. \ud83e\udd8a Agent mdw/myagent running locally on 0 .0.0.0:8181, served via https://a94073298907cd.lhr.life You can access your agent via https://app.fixie.ai/agents/mdw/myagent or ` fixie console --agent mdw/myagent ` . When running fixie agent serve , a tunnel is set up that allows the agent, running on your local machine, to be accessed from the Fixie Platform . The URL of the tunnel is printed on the console. If you quit the fixie agent serve process (e.g., by pressing Ctrl-C), the tunnel is torn down and your agent is no longer accessible. You can now use fixie console or fixie console --agent <username>/<agent_name> to send a message to your agent directly: $ fixie console Welcome to Fixie! Connected to: https://app.fixie.ai/sessions/stormy-luxuriant-ferryboat fixie \ud83e\udd8a\u276f @mdw/myagent Generate a random number between 10 and 50 @user: @mdw/myagent Generate a random number between 10 and 50 @myagent: Generate a random number between 10 and 50 @myagent: Ask Func: 10 , 50 @myagent: Func says: 48 @myagent: The random number is 48 . 1 \u276f The random number is 48 . In the fixie agent serve window, you should also see debugging output showing that your agent code was invoked with a POST request to the /genrand endpoint.","title":"Test Your Agent"},{"location":"agent-quickstart/#deploy-your-agent","text":"Agents can be deployed on any web server that supports Python. Alternatively, you can deploy your agent directly to the Fixie platform, which will handle hosting the agent functions in the cloud. To deploy your agent, simply run fixie agent deploy : $ fixie agent deploy \u2705 Deploying... \u2705 Refreshing... This process takes about a minute to complete. Once deployed, you can use your agent via the Fixie Web UI or the fixie console tool.","title":"Deploy Your Agent"},{"location":"agent-quickstart/#agent-rest-api","text":"Once deployed (via fixie agent serve or fixie agent deploy ), your agent can also be invoked via a REST API, using a POST request to the endpoint /api/agents/<username>/<agent_handle> . For example, the fixie/calc agent can be invoked as follows: $ export FIXIE_API_KEY = <Your Fixie API key> $ curl https://app.fixie.ai/api/agents/fixie/calc \\ -H \"Authorization: Bearer ${ FIXIE_API_TOKEN } \" \\ -H \"Content-Type: application/json\" \\ -d '{ \"message\": {\"text\": \"What is 999 + 222?\" }}' Your Fixie API key can be obtained from your user profile page.","title":"Agent REST API"},{"location":"agent-quickstart/#fixie-graphql-api","text":"Apart from the Agent REST API described above, the Fixie GraphQL API is a more rich and powerful API surface for interacting with Fixie, including creating agents, sending messages, and more. For more information, see the Fixie GraphQL API documentation .","title":"Fixie GraphQL API"},{"location":"agent-quickstart/#implementing-agents-without-python","text":"Refer to the Agent Protocol documentation for details on implementing an agent in a language other than Python. For complete information on the Fixie Agent API, see Agent API .","title":"Implementing Agents without Python"},{"location":"agents/","text":"Developing a Fixie Agent The Fixie platform enables you to build agents in any language by writing a service that conforms to the protocol described in Agent Protocol . For Python developers, we provide a Python library for implementing agents using the API described below. For a quick start on building your own Fixie agent, review the Quick Start guide. See Fixie Agent Python API for the full API reference. CodeShotAgent The base class for agents in Fixie is CodeShotAgent . This class handles communication with the Fixie platform via the Agent Protocol and provides a simple API for registering functions that can be invoked by the few-shot examples used by the agent. A typical CodeShotAgent structure looks like this: import fixieai BASE_PROMPT = \"Base prompt for the agent.\" FEW_SHOTS = \"\"\" Q: Example query for the agent Ask Func[my_func]: query to the func Func[my_func] says: response to the query A: Response generated by the agent Q: Second example query to the agent A: Second response generated by the agent \"\"\" agent = fixieai . CodeShotAgent ( BASE_PROMPT , FEW_SHOTS ) @agent . register_func () def my_func ( query : fixieai . Message ) -> str : return \"Response to the query\" The BASE_PROMPT and FEW_SHOTS strings provide examples for the underlying Large Language Model (LLM), such as GPT-4, as well as supply the Fixie Platform with information about the types of queries this agent can support. FEW_SHOTS must be a string composed of one or more stanzas , where each stanza consists of a question, one or more rounds of internal actions taken by the agent, and a final answer. Stanzas must be separated by a blank line. The query line in the stanza must start with Q: , and the answer line must start with A: . Internal actions taken by the agent can be one of two forms: Ask Func[<func_name>]: <query_text> : This indicates that the function <func_name> should be invoked when the output of the underlying LLM starts with this string. The string following Ask Func[<func_name>]: is passed to the function as the query.text parameter. Ask Agent[<agent_name>]: <query_text> : This indicates that the agent <agent_name> should be invoked when the output of the underlying LLM starts with this string. The string following Ask Agent[<agent_name>]: is passed to the agent as the query.text parameter. Agent Funcs A Func is a Python function that the agent can invoke. (To implement Funcs in languages other than Python, create a service that implements the Fixie Agent Protocol .) When the language model for an agent emits the token Ask Func[<func_name>] , the function <func_name> will be invoked. The register_func decorator is used to register a function for invocation by the agent. A function registered with the register_func decorator has the signature: @agent . register_func () def my_func ( query , user_storage = None , oauth_handler = None ): ... The query parameter is either a str or a Message object. If the query parameter is a string, this parameter contains the text of the agent query. If the query parameter is a Message object, this parameter contains the text of the agent along with zero or more Embed objects, as described in the Embeds section below. The optional user_storage parameter provides the Func an interface to the Fixie User Storage service, as described below. The optional oauth_handler parameter provides the Func an interface for performing OAuth authentication with external services, as described in the OAuth section below. The function must return either a str or a Message object. Returning a string is equivalent to returning a Message object with the string as its text field and no embeds . Embeds Embeds enable the association of arbitrary binary data with a query or response Message in Fixie, similar to email attachments. Embeds can be used to store images, videos, text, or any other binary data. Embeds are represented by the Embed class. Agents can access the Embeds associated with a Message as follows: @agent . register_func () def my_func ( query : fixieai . Message ) -> str : for key , embed in query . embeds . items (): print ( f \"Embed key: { key } \" ) print ( f \"Embed content-type: { embed . content_type } \" ) embed_value_as_text = embed . text embed_value_as_bytes = embed . content An agent function can also add an Embed to its response Message by adding it to the embeds dictionary of the Message object: @agent . register_func () def my_func ( query : fixieai . Message ) -> fixieai . Message : reply = fixieai . Message ( \"Response to the query\" ) reply . embeds [ \"my_embed\" ] = fixieai . Embed ( content_type = \"text/plain\" ) reply . embeds [ \"my_embed\" ] . text = \"Hello, world!\" Embeds can be queried by leveraging the built-in fixie_query_embed func. e.g., Ask Func[fixie_query_embed] . See example of how this works. External Knowledge Base Support Fixie agents come with built-in support for indexing and querying external knowledge in the form of URLs. See the support agent for an example of how to use this. URLS = [ \"https://docs.fixie.ai/*\" , ] DOCS = [ fixieai . DocumentCorpus ( urls = URLS )] agent = fixieai . CodeShotAgent ( BASE_PROMPT , FEW_SHOTS , DOCS ) Appending * to the end of the URL will tell Fixie to automatically index all children of the root URL. After indexing, you can query the corpus using the built-in Ask Func[fixie_query_corpus] function. Note: It can take up to 10 minutes to index content, depending on the number of URLs and content size. We're working on a mechanism to alert you to indexing progress. Stay tuned! User Storage Fixie agents can store and retrieve arbitrary data associated with a user using the UserStorage class. This class provides a simple interface to a persistent key/value storage service, with a separate key/value store for each Fixie user. This can be used to maintain state about a particular user that persists across agent invocations. The UserStorage instance for a given query can be obtained by providing a user_storage parameter to an agent function. The UserStorage object acts as a Python dict that stores state associated with an arbitrary string key. UserStorage values may consist of Python primitive types, such as str , int , float , bool , None , or bytes , as well as lists of these types, or a dict mapping a str to one of these types. User Storage Example @agent . register_func () def my_func ( query : fixieai . Message , user_storage : fixieai . UserStorage ) -> str : user_storage [ \"my_key\" ] = \"my_value\" return user_storage [ \"my_key\" ] Agent OAuth Support Fixie Agents can authenticate to third-party services to perform actions on behalf of the user. This is done using OAuth 2.0, a standard protocol for authorization. OAuth 2.0 allows users to grant limited access to their accounts on one service, to another service, without having to share their password. Fixie provides a simple interface for agents to perform OAuth authentication, using the OAuthParams class. Using this class, an agent function can use the OAuthHandler class, passed to the function as the oauth_handler parameter, to obtain an access token for the user. OAuth Example import fixieai oauth_params = fixieai . OAuthParams ( client_id = \"XXXXX.apps.googleusercontent.com\" , auth_uri = \"https://accounts.google.com/o/oauth2/auth\" , token_uri = \"https://oauth2.googleapis.com/token\" , client_secret = \"XXXXXXXXX\" , scopes = [ \"https://www.googleapis.com/auth/calendar.events\" ] ) agent = fixieai . CodeShotAgent ( BASE_PROMPT , FEW_SHOTS , oauth_params = oauth_params ) @agent . register_func def my_func ( query , oauth_handler : fixieai . OAuthHandler ): user_token = oauth_handler . user_token () if user_token is None : # Return the URL that the user should click on to authorize the agent. return oauth_handler . get_authorization_url () # Do something with the user_token returned by the OAuth handler. client = gcalendar_client . GcalendarClient ( user_token ) # ... Default Agent Model and Model Parameters By default, agents use the text-davinci-003 model from OpenAI with a default temperature of 0 and a maximum_tokens size of 1,000. We've found this to be the right default for many use cases, but it's easy to change by passing llm_settings when initializing your CodeShotAgent . Example: agent = fixieai . CodeShotAgent ( BASE_PROMPT , [], conversational = True , llm_settings = fixieai . LlmSettings ( temperature = 1.0 , model = \"openai/gpt-4\" , maximum_tokens = 500 ), ) Supported Models: Model Name Identifier String GPT-3 openai/text-davinci-003 (default) GPT-3.5 (ChatGPT) openai/gpt-3.5-turbo GPT-4 openai/gpt-4 AI21 J2 Grande ai21/j2-grande AI21 J2 Jumbo ai21/j2-jumbo GooseAI GPTJ 6B gooseai/gpt-j-6b GooseAI GPT NEO 20B gooseai/gpt-neo-20b Built-In Functions All Fixie agents have access to the following built-in functions that they can invoke: Ask Func[fixie_base_prompt] : Returns the base prompt for the agent. Ask Func[fixie_local_datetime] : Returns the current date and time in the user's local timezone. Ask Func[fixie_utc_datetime] : Returns the current date and time in the UTC timezone. Ask Func[fixie_query_embed] : Executes the prompt in the query against the contents of the embed. Ask Func[fixie_query_corpus] : Executes the prompt in the query against the contents of the agent-defined corpus.","title":"Fixie Agent API"},{"location":"agents/#developing-a-fixie-agent","text":"The Fixie platform enables you to build agents in any language by writing a service that conforms to the protocol described in Agent Protocol . For Python developers, we provide a Python library for implementing agents using the API described below. For a quick start on building your own Fixie agent, review the Quick Start guide. See Fixie Agent Python API for the full API reference.","title":"Developing a Fixie Agent"},{"location":"agents/#codeshotagent","text":"The base class for agents in Fixie is CodeShotAgent . This class handles communication with the Fixie platform via the Agent Protocol and provides a simple API for registering functions that can be invoked by the few-shot examples used by the agent. A typical CodeShotAgent structure looks like this: import fixieai BASE_PROMPT = \"Base prompt for the agent.\" FEW_SHOTS = \"\"\" Q: Example query for the agent Ask Func[my_func]: query to the func Func[my_func] says: response to the query A: Response generated by the agent Q: Second example query to the agent A: Second response generated by the agent \"\"\" agent = fixieai . CodeShotAgent ( BASE_PROMPT , FEW_SHOTS ) @agent . register_func () def my_func ( query : fixieai . Message ) -> str : return \"Response to the query\" The BASE_PROMPT and FEW_SHOTS strings provide examples for the underlying Large Language Model (LLM), such as GPT-4, as well as supply the Fixie Platform with information about the types of queries this agent can support. FEW_SHOTS must be a string composed of one or more stanzas , where each stanza consists of a question, one or more rounds of internal actions taken by the agent, and a final answer. Stanzas must be separated by a blank line. The query line in the stanza must start with Q: , and the answer line must start with A: . Internal actions taken by the agent can be one of two forms: Ask Func[<func_name>]: <query_text> : This indicates that the function <func_name> should be invoked when the output of the underlying LLM starts with this string. The string following Ask Func[<func_name>]: is passed to the function as the query.text parameter. Ask Agent[<agent_name>]: <query_text> : This indicates that the agent <agent_name> should be invoked when the output of the underlying LLM starts with this string. The string following Ask Agent[<agent_name>]: is passed to the agent as the query.text parameter.","title":"CodeShotAgent"},{"location":"agents/#agent-funcs","text":"A Func is a Python function that the agent can invoke. (To implement Funcs in languages other than Python, create a service that implements the Fixie Agent Protocol .) When the language model for an agent emits the token Ask Func[<func_name>] , the function <func_name> will be invoked. The register_func decorator is used to register a function for invocation by the agent. A function registered with the register_func decorator has the signature: @agent . register_func () def my_func ( query , user_storage = None , oauth_handler = None ): ... The query parameter is either a str or a Message object. If the query parameter is a string, this parameter contains the text of the agent query. If the query parameter is a Message object, this parameter contains the text of the agent along with zero or more Embed objects, as described in the Embeds section below. The optional user_storage parameter provides the Func an interface to the Fixie User Storage service, as described below. The optional oauth_handler parameter provides the Func an interface for performing OAuth authentication with external services, as described in the OAuth section below. The function must return either a str or a Message object. Returning a string is equivalent to returning a Message object with the string as its text field and no embeds .","title":"Agent Funcs"},{"location":"agents/#embeds","text":"Embeds enable the association of arbitrary binary data with a query or response Message in Fixie, similar to email attachments. Embeds can be used to store images, videos, text, or any other binary data. Embeds are represented by the Embed class. Agents can access the Embeds associated with a Message as follows: @agent . register_func () def my_func ( query : fixieai . Message ) -> str : for key , embed in query . embeds . items (): print ( f \"Embed key: { key } \" ) print ( f \"Embed content-type: { embed . content_type } \" ) embed_value_as_text = embed . text embed_value_as_bytes = embed . content An agent function can also add an Embed to its response Message by adding it to the embeds dictionary of the Message object: @agent . register_func () def my_func ( query : fixieai . Message ) -> fixieai . Message : reply = fixieai . Message ( \"Response to the query\" ) reply . embeds [ \"my_embed\" ] = fixieai . Embed ( content_type = \"text/plain\" ) reply . embeds [ \"my_embed\" ] . text = \"Hello, world!\" Embeds can be queried by leveraging the built-in fixie_query_embed func. e.g., Ask Func[fixie_query_embed] . See example of how this works.","title":"Embeds"},{"location":"agents/#external-knowledge-base-support","text":"Fixie agents come with built-in support for indexing and querying external knowledge in the form of URLs. See the support agent for an example of how to use this. URLS = [ \"https://docs.fixie.ai/*\" , ] DOCS = [ fixieai . DocumentCorpus ( urls = URLS )] agent = fixieai . CodeShotAgent ( BASE_PROMPT , FEW_SHOTS , DOCS ) Appending * to the end of the URL will tell Fixie to automatically index all children of the root URL. After indexing, you can query the corpus using the built-in Ask Func[fixie_query_corpus] function. Note: It can take up to 10 minutes to index content, depending on the number of URLs and content size. We're working on a mechanism to alert you to indexing progress. Stay tuned!","title":"External Knowledge Base Support"},{"location":"agents/#user-storage","text":"Fixie agents can store and retrieve arbitrary data associated with a user using the UserStorage class. This class provides a simple interface to a persistent key/value storage service, with a separate key/value store for each Fixie user. This can be used to maintain state about a particular user that persists across agent invocations. The UserStorage instance for a given query can be obtained by providing a user_storage parameter to an agent function. The UserStorage object acts as a Python dict that stores state associated with an arbitrary string key. UserStorage values may consist of Python primitive types, such as str , int , float , bool , None , or bytes , as well as lists of these types, or a dict mapping a str to one of these types.","title":"User Storage"},{"location":"agents/#user-storage-example","text":"@agent . register_func () def my_func ( query : fixieai . Message , user_storage : fixieai . UserStorage ) -> str : user_storage [ \"my_key\" ] = \"my_value\" return user_storage [ \"my_key\" ]","title":"User Storage Example"},{"location":"agents/#agent-oauth-support","text":"Fixie Agents can authenticate to third-party services to perform actions on behalf of the user. This is done using OAuth 2.0, a standard protocol for authorization. OAuth 2.0 allows users to grant limited access to their accounts on one service, to another service, without having to share their password. Fixie provides a simple interface for agents to perform OAuth authentication, using the OAuthParams class. Using this class, an agent function can use the OAuthHandler class, passed to the function as the oauth_handler parameter, to obtain an access token for the user.","title":"Agent OAuth Support"},{"location":"agents/#oauth-example","text":"import fixieai oauth_params = fixieai . OAuthParams ( client_id = \"XXXXX.apps.googleusercontent.com\" , auth_uri = \"https://accounts.google.com/o/oauth2/auth\" , token_uri = \"https://oauth2.googleapis.com/token\" , client_secret = \"XXXXXXXXX\" , scopes = [ \"https://www.googleapis.com/auth/calendar.events\" ] ) agent = fixieai . CodeShotAgent ( BASE_PROMPT , FEW_SHOTS , oauth_params = oauth_params ) @agent . register_func def my_func ( query , oauth_handler : fixieai . OAuthHandler ): user_token = oauth_handler . user_token () if user_token is None : # Return the URL that the user should click on to authorize the agent. return oauth_handler . get_authorization_url () # Do something with the user_token returned by the OAuth handler. client = gcalendar_client . GcalendarClient ( user_token ) # ...","title":"OAuth Example"},{"location":"agents/#default-agent-model-and-model-parameters","text":"By default, agents use the text-davinci-003 model from OpenAI with a default temperature of 0 and a maximum_tokens size of 1,000. We've found this to be the right default for many use cases, but it's easy to change by passing llm_settings when initializing your CodeShotAgent .","title":"Default Agent Model and Model Parameters"},{"location":"agents/#example","text":"agent = fixieai . CodeShotAgent ( BASE_PROMPT , [], conversational = True , llm_settings = fixieai . LlmSettings ( temperature = 1.0 , model = \"openai/gpt-4\" , maximum_tokens = 500 ), )","title":"Example:"},{"location":"agents/#supported-models","text":"Model Name Identifier String GPT-3 openai/text-davinci-003 (default) GPT-3.5 (ChatGPT) openai/gpt-3.5-turbo GPT-4 openai/gpt-4 AI21 J2 Grande ai21/j2-grande AI21 J2 Jumbo ai21/j2-jumbo GooseAI GPTJ 6B gooseai/gpt-j-6b GooseAI GPT NEO 20B gooseai/gpt-neo-20b","title":"Supported Models:"},{"location":"agents/#built-in-functions","text":"All Fixie agents have access to the following built-in functions that they can invoke: Ask Func[fixie_base_prompt] : Returns the base prompt for the agent. Ask Func[fixie_local_datetime] : Returns the current date and time in the user's local timezone. Ask Func[fixie_utc_datetime] : Returns the current date and time in the UTC timezone. Ask Func[fixie_query_embed] : Executes the prompt in the query against the contents of the embed. Ask Func[fixie_query_corpus] : Executes the prompt in the query against the contents of the agent-defined corpus.","title":"Built-In Functions"},{"location":"architecture/","text":"Fixie Architecture Overview This page provides a technical overview of the Fixie platform, focusing on the programming model used to build applications with Fixie. System Overview The following diagram is a high-level representation of the Fixie platform: The Fixie system comprises a cloud-hosted API (app.fixie.ai) that provides a GraphQL-based API endpoint to clients and a set of agents, each possessing a specific set of skills such as accessing a remote API, pulling data from a database, summarizing text, etc. The core Fixie service runs on the cloud. Agents can operate anywhere: hosted by Fixie, hosted by a customer, or hosted by third parties. Each agent functions as an independent microservice. Fixie's agent registry maintains metadata about each agent, including its description, owner information, and the URL where messages can be sent to the agent. GraphQL API The Fixie GraphQL API allows clients to interact with the system in several ways: Query the set of agents in the system, returning metadata about each agent, such as the name, owner, set of example queries that the agent supports, etc. Register a new agent (described in the Creating an Agent section below). Create, list, and delete Sessions. A Session can be thought of as a chat session with the Fixie system, between the client and one or more agents. Post a Message to a Session, sending a new query to Fixie for system processing. Retrieve the Messages in a Session, including those Messages sent by agents. Example Query Flow To illustrate the end-to-end system, let's walk through what happens when a client issues a query, such as \"Schedule a 30-minute meeting with Zach sometime between now and next Tuesday\". The red circled numbers on the diagram above refer to each step below. The client issues the query by posting a message to a Session via the GraphQL API or Fixie web client . The Session Runner dispatches the user's query to the Fixie agent. The Fixie agent is the first agent in the query sequence responsible for breaking users' queries into steps and dispatching them to one or more agents for processing. The Session Runner's responsibility is to maintain the running chat log of the session and provide context to the Fixie agent. For each step in the program, the Fixie agent calls the Router agent to determine which agent(s) need to be invoked to run that step of the query. The Router agent consults the agent Registry, which contains metadata about each agent, including the agent's name, owner, and sample queries it supports. The Router determines which agent to send the query to using a neural search that maps the user's query into a high-dimensional embedding space, comparing it to the sample queries for each agent in the system. The Router sends the user's query to the agent that most closely matches the agent's sample queries. The agent (in this case, the Google Calendar agent) receives the query and executes it. The process is typically done by utilizing a large language model such as GPT-4 to interpret the query and invoke one or more external systems to generate a response. Finally, the response from the agent is returned to the Fixie agent, which may decide to compose and send a final response to the user or invoke other steps of the program involving other agents. The response message is stored in the Session associated with this query, and returned to the client application. Query Message Format Queries in Fixie consist of two parts: a plain-text Message and zero or more Embeds. An example of a query message in Fixie is a JSON object that might contain: { \"text\" : \"Mask out the background in #1\" , \"embeds\" : { \"1\" : { \"content_type\" : \"image/png\" , \"uri\" : \"https://app.fixie.ai/attachment/21cfa1...\" , } } } An Embed is like an email attachment: a binary object with an associated MIME type (e.g., image/png or text/plain ) that accompanies the query. Agents can access the Embeds associated with the query and optionally create new Embeds representing the result of data processing or generation. Embeds are immutable once created, stored in a Fixie-managed cloud storage bucket, and passed by reference (using a signed URL) with the query. For example, the DALL-E and Stable Diffusion agents both create Embeds for the images they generate. The Masker agent takes an image Embed and generates a binary mask representing portions of the image that contain a given object or material (e.g. whatever is in the background of the image). The query text can refer to an Embed using its key in the message. In the example above, the Embed key is 1 , and the query refers to it using #1 . Creating an Agent A Fixie agent is a program that accepts a query (text with optional embeds) in the format shown above and returns a reply in the same format. An agent can run anywhere on the Internet; Fixie only needs to know the URL to post the query message to over HTTP. The simplest possible agent, implemented in Python, might look like this: from flask import Flask , request app = Flask ( __name__ ) @app . route ( \"/\" , methods = [ \"POST\" ]) def agent (): query = request . json [ \"text\" ] embeds = request . json [ \"embeds\" ] # Do something with the query... return { \"text\" : \"Hello, world!\" } That\u2019s it! Sending a POST request to the agent\u2019s URL will return a reply \"Hello, world!\" . Of course, most Fixie agents will want to use a large language model to process incoming queries and generate responses. There are two ways of doing this in Fixie. Fully Custom Agents An agent can do whatever it wants with the input query. Most of the time, it directly calls a Large Language Model (LLM), such as OpenAI's GPT-4. Fixie is agnostic to the agent's query processing method, which could use GPT-4, fine-tuned models like InstructGPT, or custom models from developers or third parties. Libraries like LangChain can assist in interfacing LLM with external code. An agent can also serve as a wrapper for third-party AI-powered services, such as text summarization, text generation, and search. Building an agent to wrap around services like Jasper.ai , Instructive.ai, or Copy.ai is simple. This approach interconnects and composes various functions within the Fixie ecosystem. Code Shot Agents In addition to the roll-your-own approach with custom agents, Fixie offers a novel programming model called Code Shots for building agents. In LLMs, few-shot examples typically instruct the model to perform specific tasks. Code Shots enhance few-shot examples with embedded code. A stock quote agent, for example, has a Code Shots manifest with a few-shot example set and Python code to invoke an external API for stock quotes: import fixieai import requests BASE_PROMPT = \"I am an agent that answers questions about stock prices.\" FEW_SHOTS = \"\"\"Q: What is the current price for SYMBOL? Ask Func[quote]: SYMBOL Func[quote] says: $123.45 A: The current price for SYMBOL is $123.45. Q: SYMBOL share price Ask Func[quote]: SYMBOL Func[quote] says: $34.52 A: The share price for SYMBOL is $34.52. Q: Price for SYMBOL Ask Func[quote]: SYMBOL Func[quote] says: $99.11 A: The share price for SYMBOL is $99.11 \"\"\" agent = fixieai . CodeShotAgent ( BASE_PROMPT , FEW_SHOTS ) API_KEY = \"...\" @agent . register_func () def quote ( query ): symbol = query . message . text url = f \"https://www.alphavantage.co/query?function=GLOBAL_QUOTE&apikey= { API_KEY } &symbol= { symbol } \" response = requests . get ( url ) raw_price = response . json ()[ \"Global Quote\" ][ \"05. price\" ] dot = raw_price . index ( \".\" ) return raw_price [: dot + 3 ] agent . serve ( \"stockquote\" ) This is the entire code for the stock quote agent. The code manifest consists of a set of few-shot examples (example queries and responses), coupled with a little bit of Python code that knows how to invoke an external API to fetch a stock quote. With Code Shots, the agents functionality is partitioned across two domains: the language processing (done centrally, by Fixie), and the low-level Func invocations (done within the agent's own sandbox, either in the customers infrastructure or within an environment that is hosted by us). Because a Func does not need to perform any language processing, it is just a simple function! Code Shot agents partition functionality between Fixie-managed language processing and agent-specific Func invocations within its sandbox. A Func is a simple function that doesn't require language processing. When a Code Shot agent receives a query, such as \"What is the stock price for GOOG?\" , the following steps occur: The agent gets a query like \"What is the stock price for GOOG?\" Fixie takes the user's query, along with the few-shot examples in the Code Shots manifest, and passes them to a LLM for processing. Note that this language processing is being done centrally, by Fixie. This allows Fixie to automatically select the best LLM and prompt to handle the query, as well as augment the prompt with relevant context and session history. In this case, the output of the LLM will be something like Ask Func[quote]: GOOG . This tells Fixie to invoke this low-level Func to perform the next step of processing. Fixie invokes the Func by sending a REST call over HTTP to the agent's URL, and getting back the response. Fixie then feeds the Func's response back into the LLM, again with the appropriate prompt and context, to continue processing the query. In this case, the LLM will generate a response like \"A: The share price for GOOG is $105.22\" . The final reply is sent back to the client, or the agent that issued the original query. Code Shots have several key features: Easy agent development by providing English-language examples and, if needed, simple Funcs. Creating a library of shared Funcs for evaluating computational expressions, fetching data through HTTP, and more. Registering an Agent Users can register agents in Fixie via the GraphQL API or the web interface. An agent requires a name, a short description, and a URL for query requests. Authentication Fixie associates all requests with an end user. Users can create an account by visiting the web app (https://app.fixie.ai) and signing up with email, a Google account, or a GitHub account. Access to the Fixie GraphQL API requires an API key from the user's profile page. The API key, provided as an Authorization: Bearer header, identifies the user linked to the query as a JWT signed by the Fixie service. Fixie includes user and session ID information in agent request JWTs. Agents verify incoming queries by checking the JWT signature. When sending queries to another agent or invoking Fixie's API endpoints, the agent must provide the JWT. Usage Limits Fixie enforces generous usage limits on individual users and agents to prevent abuse. The current per-user daily limit is set at 1,000 queries. If needed, the limit can be increased or users may purchase additional credits. Agents invoking Fixie APIs, like the User Storage mechanism described below, also have rate limits on those calls. Code Shot agents using Fixie's language processing capabilities have token limits for the Fixie-provided LLM API within specific time periods. User Storage Agents often need to maintain state related to a user or chat session. While agents could create their own storage mechanisms (e.g., writing data to a database or cloud storage bucket), Fixie provides a simple API for this purpose. Fixie's User Storage component offers a basic key-value store, enabling agents to store and retrieve binary blobs linked to an agent-provided key. This arrangement is similar to cookies in a web browser context, allowing agents to store information for later access.","title":"Architecture"},{"location":"architecture/#fixie-architecture-overview","text":"This page provides a technical overview of the Fixie platform, focusing on the programming model used to build applications with Fixie.","title":"Fixie Architecture Overview"},{"location":"architecture/#system-overview","text":"The following diagram is a high-level representation of the Fixie platform: The Fixie system comprises a cloud-hosted API (app.fixie.ai) that provides a GraphQL-based API endpoint to clients and a set of agents, each possessing a specific set of skills such as accessing a remote API, pulling data from a database, summarizing text, etc. The core Fixie service runs on the cloud. Agents can operate anywhere: hosted by Fixie, hosted by a customer, or hosted by third parties. Each agent functions as an independent microservice. Fixie's agent registry maintains metadata about each agent, including its description, owner information, and the URL where messages can be sent to the agent.","title":"System Overview"},{"location":"architecture/#graphql-api","text":"The Fixie GraphQL API allows clients to interact with the system in several ways: Query the set of agents in the system, returning metadata about each agent, such as the name, owner, set of example queries that the agent supports, etc. Register a new agent (described in the Creating an Agent section below). Create, list, and delete Sessions. A Session can be thought of as a chat session with the Fixie system, between the client and one or more agents. Post a Message to a Session, sending a new query to Fixie for system processing. Retrieve the Messages in a Session, including those Messages sent by agents.","title":"GraphQL API"},{"location":"architecture/#example-query-flow","text":"To illustrate the end-to-end system, let's walk through what happens when a client issues a query, such as \"Schedule a 30-minute meeting with Zach sometime between now and next Tuesday\". The red circled numbers on the diagram above refer to each step below. The client issues the query by posting a message to a Session via the GraphQL API or Fixie web client . The Session Runner dispatches the user's query to the Fixie agent. The Fixie agent is the first agent in the query sequence responsible for breaking users' queries into steps and dispatching them to one or more agents for processing. The Session Runner's responsibility is to maintain the running chat log of the session and provide context to the Fixie agent. For each step in the program, the Fixie agent calls the Router agent to determine which agent(s) need to be invoked to run that step of the query. The Router agent consults the agent Registry, which contains metadata about each agent, including the agent's name, owner, and sample queries it supports. The Router determines which agent to send the query to using a neural search that maps the user's query into a high-dimensional embedding space, comparing it to the sample queries for each agent in the system. The Router sends the user's query to the agent that most closely matches the agent's sample queries. The agent (in this case, the Google Calendar agent) receives the query and executes it. The process is typically done by utilizing a large language model such as GPT-4 to interpret the query and invoke one or more external systems to generate a response. Finally, the response from the agent is returned to the Fixie agent, which may decide to compose and send a final response to the user or invoke other steps of the program involving other agents. The response message is stored in the Session associated with this query, and returned to the client application.","title":"Example Query Flow"},{"location":"architecture/#query-message-format","text":"Queries in Fixie consist of two parts: a plain-text Message and zero or more Embeds. An example of a query message in Fixie is a JSON object that might contain: { \"text\" : \"Mask out the background in #1\" , \"embeds\" : { \"1\" : { \"content_type\" : \"image/png\" , \"uri\" : \"https://app.fixie.ai/attachment/21cfa1...\" , } } } An Embed is like an email attachment: a binary object with an associated MIME type (e.g., image/png or text/plain ) that accompanies the query. Agents can access the Embeds associated with the query and optionally create new Embeds representing the result of data processing or generation. Embeds are immutable once created, stored in a Fixie-managed cloud storage bucket, and passed by reference (using a signed URL) with the query. For example, the DALL-E and Stable Diffusion agents both create Embeds for the images they generate. The Masker agent takes an image Embed and generates a binary mask representing portions of the image that contain a given object or material (e.g. whatever is in the background of the image). The query text can refer to an Embed using its key in the message. In the example above, the Embed key is 1 , and the query refers to it using #1 .","title":"Query Message Format"},{"location":"architecture/#creating-an-agent","text":"A Fixie agent is a program that accepts a query (text with optional embeds) in the format shown above and returns a reply in the same format. An agent can run anywhere on the Internet; Fixie only needs to know the URL to post the query message to over HTTP. The simplest possible agent, implemented in Python, might look like this: from flask import Flask , request app = Flask ( __name__ ) @app . route ( \"/\" , methods = [ \"POST\" ]) def agent (): query = request . json [ \"text\" ] embeds = request . json [ \"embeds\" ] # Do something with the query... return { \"text\" : \"Hello, world!\" } That\u2019s it! Sending a POST request to the agent\u2019s URL will return a reply \"Hello, world!\" . Of course, most Fixie agents will want to use a large language model to process incoming queries and generate responses. There are two ways of doing this in Fixie.","title":"Creating an Agent"},{"location":"architecture/#fully-custom-agents","text":"An agent can do whatever it wants with the input query. Most of the time, it directly calls a Large Language Model (LLM), such as OpenAI's GPT-4. Fixie is agnostic to the agent's query processing method, which could use GPT-4, fine-tuned models like InstructGPT, or custom models from developers or third parties. Libraries like LangChain can assist in interfacing LLM with external code. An agent can also serve as a wrapper for third-party AI-powered services, such as text summarization, text generation, and search. Building an agent to wrap around services like Jasper.ai , Instructive.ai, or Copy.ai is simple. This approach interconnects and composes various functions within the Fixie ecosystem.","title":"Fully Custom Agents"},{"location":"architecture/#code-shot-agents","text":"In addition to the roll-your-own approach with custom agents, Fixie offers a novel programming model called Code Shots for building agents. In LLMs, few-shot examples typically instruct the model to perform specific tasks. Code Shots enhance few-shot examples with embedded code. A stock quote agent, for example, has a Code Shots manifest with a few-shot example set and Python code to invoke an external API for stock quotes: import fixieai import requests BASE_PROMPT = \"I am an agent that answers questions about stock prices.\" FEW_SHOTS = \"\"\"Q: What is the current price for SYMBOL? Ask Func[quote]: SYMBOL Func[quote] says: $123.45 A: The current price for SYMBOL is $123.45. Q: SYMBOL share price Ask Func[quote]: SYMBOL Func[quote] says: $34.52 A: The share price for SYMBOL is $34.52. Q: Price for SYMBOL Ask Func[quote]: SYMBOL Func[quote] says: $99.11 A: The share price for SYMBOL is $99.11 \"\"\" agent = fixieai . CodeShotAgent ( BASE_PROMPT , FEW_SHOTS ) API_KEY = \"...\" @agent . register_func () def quote ( query ): symbol = query . message . text url = f \"https://www.alphavantage.co/query?function=GLOBAL_QUOTE&apikey= { API_KEY } &symbol= { symbol } \" response = requests . get ( url ) raw_price = response . json ()[ \"Global Quote\" ][ \"05. price\" ] dot = raw_price . index ( \".\" ) return raw_price [: dot + 3 ] agent . serve ( \"stockquote\" ) This is the entire code for the stock quote agent. The code manifest consists of a set of few-shot examples (example queries and responses), coupled with a little bit of Python code that knows how to invoke an external API to fetch a stock quote. With Code Shots, the agents functionality is partitioned across two domains: the language processing (done centrally, by Fixie), and the low-level Func invocations (done within the agent's own sandbox, either in the customers infrastructure or within an environment that is hosted by us). Because a Func does not need to perform any language processing, it is just a simple function! Code Shot agents partition functionality between Fixie-managed language processing and agent-specific Func invocations within its sandbox. A Func is a simple function that doesn't require language processing. When a Code Shot agent receives a query, such as \"What is the stock price for GOOG?\" , the following steps occur: The agent gets a query like \"What is the stock price for GOOG?\" Fixie takes the user's query, along with the few-shot examples in the Code Shots manifest, and passes them to a LLM for processing. Note that this language processing is being done centrally, by Fixie. This allows Fixie to automatically select the best LLM and prompt to handle the query, as well as augment the prompt with relevant context and session history. In this case, the output of the LLM will be something like Ask Func[quote]: GOOG . This tells Fixie to invoke this low-level Func to perform the next step of processing. Fixie invokes the Func by sending a REST call over HTTP to the agent's URL, and getting back the response. Fixie then feeds the Func's response back into the LLM, again with the appropriate prompt and context, to continue processing the query. In this case, the LLM will generate a response like \"A: The share price for GOOG is $105.22\" . The final reply is sent back to the client, or the agent that issued the original query. Code Shots have several key features: Easy agent development by providing English-language examples and, if needed, simple Funcs. Creating a library of shared Funcs for evaluating computational expressions, fetching data through HTTP, and more.","title":"Code Shot Agents"},{"location":"architecture/#registering-an-agent","text":"Users can register agents in Fixie via the GraphQL API or the web interface. An agent requires a name, a short description, and a URL for query requests.","title":"Registering an Agent"},{"location":"architecture/#authentication","text":"Fixie associates all requests with an end user. Users can create an account by visiting the web app (https://app.fixie.ai) and signing up with email, a Google account, or a GitHub account. Access to the Fixie GraphQL API requires an API key from the user's profile page. The API key, provided as an Authorization: Bearer header, identifies the user linked to the query as a JWT signed by the Fixie service. Fixie includes user and session ID information in agent request JWTs. Agents verify incoming queries by checking the JWT signature. When sending queries to another agent or invoking Fixie's API endpoints, the agent must provide the JWT.","title":"Authentication"},{"location":"architecture/#usage-limits","text":"Fixie enforces generous usage limits on individual users and agents to prevent abuse. The current per-user daily limit is set at 1,000 queries. If needed, the limit can be increased or users may purchase additional credits. Agents invoking Fixie APIs, like the User Storage mechanism described below, also have rate limits on those calls. Code Shot agents using Fixie's language processing capabilities have token limits for the Fixie-provided LLM API within specific time periods.","title":"Usage Limits"},{"location":"architecture/#user-storage","text":"Agents often need to maintain state related to a user or chat session. While agents could create their own storage mechanisms (e.g., writing data to a database or cloud storage bucket), Fixie provides a simple API for this purpose. Fixie's User Storage component offers a basic key-value store, enabling agents to store and retrieve binary blobs linked to an agent-provided key. This arrangement is similar to cookies in a web browser context, allowing agents to store information for later access.","title":"User Storage"},{"location":"cli/","text":"Fixie CLI Reference This page provides documentation for the Fixie command line tool. fixie Command-line interface to the Fixie platform. Usage: fixie [ OPTIONS ] COMMAND [ ARGS ] ... Options: -- help Show this message and exit . agent Agent-related commands. Usage: fixie agent [ OPTIONS ] COMMAND [ ARGS ] ... Options: -- help Show this message and exit . delete Delete an agent. Usage: fixie agent delete [ OPTIONS ] HANDLE Options: -- help Show this message and exit . deploy Deploy the current agent. Usage: fixie agent deploy [ OPTIONS ] [ PATH ] Options: -- metadata - only ( No longer supported . ) -- public Make the agent public . -- validate / -- no - validate ( default enabled ) Validate that the agent loads in a local venv before deploying . -- current / -- not - current ( default enabled ) Change the current revision to the deployed revision . -- metadata TEXT ... Additional metadata to associate with the revision . -- reindex / -- no - reindex Force any corpora to be reindexed . -- help Show this message and exit . init Creates an agent.yaml file. Usage: fixie agent init [ OPTIONS ] [ PATH ] Options: -- handle TEXT -- description TEXT -- entry - point TEXT -- more - info - url TEXT -- requirement TEXT Additional requirements for requirements . txt . Can be specified multiple times . -- help Show this message and exit . list List agents. Usage: fixie agent list [ OPTIONS ] Options: -- verbose Enable verbose output . -- help Show this message and exit . publish Make the current agent public. Usage: fixie agent publish [ OPTIONS ] [ PATH ] Options: -- help Show this message and exit . revisions Revisions-related commands. Usage: fixie agent revisions [ OPTIONS ] COMMAND [ ARGS ] ... Options: -- help Show this message and exit . delete Deletes a revision of an agent. Usage: fixie agent revisions delete [ OPTIONS ] [ PATH ] Options: -- id TEXT The revision ID to delete . [ required ] -- force / - f Delete the revision even if it is the current one . --help Show this message and exit. list Lists the revisions associated with an agent. Usage: fixie agent revisions list [ OPTIONS ] [ PATH ] Options: -- json -- help Show this message and exit . set-current Sets the current (active) revision of an agent. Usage: fixie agent revisions set - current [ OPTIONS ] [ PATH ] Options: -- id TEXT The revision ID to make current . [ required ] --help Show this message and exit. serve Serve the current agent locally via a publicly-accessible URL. Usage: fixie agent serve [ OPTIONS ] [ PATH ] Options: -- host TEXT -- port INTEGER -- tunnel / -- no - tunnel ( default enabled ) Create a tunnel using localhost . run . -- reload / -- no - reload ( default enabled ) Reload automatically . -- venv / -- no - venv Run from virtual environment -- help Show this message and exit . show Show an agent. Usage: fixie agent show [ OPTIONS ] AGENT_ID Options: -- help Show this message and exit . unpublish Make the current agent not public. Usage: fixie agent unpublish [ OPTIONS ] [ PATH ] Options: -- help Show this message and exit . auth Authorizes fixie to access Fixie platform. Usage: fixie auth [ OPTIONS ] Options: -- force Forces authentication , even if the user is authenticated . -- help Show this message and exit . deploy Deploy the current agent. Usage: fixie deploy [ OPTIONS ] [ PATH ] Options: -- metadata - only ( No longer supported . ) -- public Make the agent public . -- validate / -- no - validate ( default enabled ) Validate that the agent loads in a local venv before deploying . -- current / -- not - current ( default enabled ) Change the current revision to the deployed revision . -- metadata TEXT ... Additional metadata to associate with the revision . -- reindex / -- no - reindex Force any corpora to be reindexed . -- help Show this message and exit . init Creates an agent.yaml file. Usage: fixie init [ OPTIONS ] [ PATH ] Options: -- handle TEXT -- description TEXT -- entry - point TEXT -- more - info - url TEXT -- requirement TEXT Additional requirements for requirements . txt . Can be specified multiple times . -- help Show this message and exit . new Creates a new session and opens it. Usage: fixie new [ OPTIONS ] [ MESSAGE ] Options: -- web Open the session in the web interface . - a , -- agent TEXT A specific agent to talk to . If unset , `fixie` is used . - v , -- verbose Enable verbose output . -- help Show this message and exit . publish Make the current agent public. Usage: fixie publish [ OPTIONS ] [ PATH ] Options: -- help Show this message and exit . query Runs a single query and exit. Usage: fixie query [ OPTIONS ] MESSAGE Options: -- web Open the session in the web interface . -- keep Do not delete the session after use . - v , -- verbose Enable verbose output . - a , -- agent TEXT A specific agent to talk to . If unset , `fixie` is used . -- help Show this message and exit . serve Serve the current agent locally via a publicly-accessible URL. Usage: fixie serve [ OPTIONS ] [ PATH ] Options: -- host TEXT -- port INTEGER -- tunnel / -- no - tunnel ( default enabled ) Create a tunnel using localhost . run . -- reload / -- no - reload ( default enabled ) Reload automatically . -- venv / -- no - venv Run from virtual environment -- help Show this message and exit . session Session-related commands. Usage: fixie session [ OPTIONS ] COMMAND [ ARGS ] ... Options: -- help Show this message and exit . list Lists sessions. Usage: fixie session list [ OPTIONS ] Options: -- help Show this message and exit . new Creates a new session and opens it. Usage: fixie session new [ OPTIONS ] [ MESSAGE ] Options: -- web Open the session in the web interface . - a , -- agent TEXT A specific agent to talk to . If unset , `fixie` is used . - v , -- verbose Enable verbose output . -- help Show this message and exit . open Opens a session. Usage: fixie session open [ OPTIONS ] SESSION_ID [ MESSAGE ] Options: -- web Open the session in the web interface . - a , -- agent TEXT A specific agent to talk to . If unset , `fixie` is used . - v , -- verbose Enable verbose output . -- help Show this message and exit . query Runs a single query and exit. Usage: fixie session query [ OPTIONS ] MESSAGE Options: -- web Open the session in the web interface . -- keep Do not delete the session after use . - v , -- verbose Enable verbose output . - a , -- agent TEXT A specific agent to talk to . If unset , `fixie` is used . -- help Show this message and exit . unpublish Make the current agent not public. Usage: fixie unpublish [ OPTIONS ] [ PATH ] Options: -- help Show this message and exit . user Displays information on the authenticated user. Usage: fixie user [ OPTIONS ] Options: -- help Show this message and exit .","title":"CLI"},{"location":"cli/#fixie-cli-reference","text":"This page provides documentation for the Fixie command line tool.","title":"Fixie CLI Reference"},{"location":"cli/#fixie","text":"Command-line interface to the Fixie platform. Usage: fixie [ OPTIONS ] COMMAND [ ARGS ] ... Options: -- help Show this message and exit .","title":"fixie"},{"location":"cli/#agent","text":"Agent-related commands. Usage: fixie agent [ OPTIONS ] COMMAND [ ARGS ] ... Options: -- help Show this message and exit .","title":"agent"},{"location":"cli/#delete","text":"Delete an agent. Usage: fixie agent delete [ OPTIONS ] HANDLE Options: -- help Show this message and exit .","title":"delete"},{"location":"cli/#deploy","text":"Deploy the current agent. Usage: fixie agent deploy [ OPTIONS ] [ PATH ] Options: -- metadata - only ( No longer supported . ) -- public Make the agent public . -- validate / -- no - validate ( default enabled ) Validate that the agent loads in a local venv before deploying . -- current / -- not - current ( default enabled ) Change the current revision to the deployed revision . -- metadata TEXT ... Additional metadata to associate with the revision . -- reindex / -- no - reindex Force any corpora to be reindexed . -- help Show this message and exit .","title":"deploy"},{"location":"cli/#init","text":"Creates an agent.yaml file. Usage: fixie agent init [ OPTIONS ] [ PATH ] Options: -- handle TEXT -- description TEXT -- entry - point TEXT -- more - info - url TEXT -- requirement TEXT Additional requirements for requirements . txt . Can be specified multiple times . -- help Show this message and exit .","title":"init"},{"location":"cli/#list","text":"List agents. Usage: fixie agent list [ OPTIONS ] Options: -- verbose Enable verbose output . -- help Show this message and exit .","title":"list"},{"location":"cli/#publish","text":"Make the current agent public. Usage: fixie agent publish [ OPTIONS ] [ PATH ] Options: -- help Show this message and exit .","title":"publish"},{"location":"cli/#revisions","text":"Revisions-related commands. Usage: fixie agent revisions [ OPTIONS ] COMMAND [ ARGS ] ... Options: -- help Show this message and exit .","title":"revisions"},{"location":"cli/#delete_1","text":"Deletes a revision of an agent. Usage: fixie agent revisions delete [ OPTIONS ] [ PATH ] Options: -- id TEXT The revision ID to delete . [ required ] -- force / - f Delete the revision even if it is the current one . --help Show this message and exit.","title":"delete"},{"location":"cli/#list_1","text":"Lists the revisions associated with an agent. Usage: fixie agent revisions list [ OPTIONS ] [ PATH ] Options: -- json -- help Show this message and exit .","title":"list"},{"location":"cli/#set-current","text":"Sets the current (active) revision of an agent. Usage: fixie agent revisions set - current [ OPTIONS ] [ PATH ] Options: -- id TEXT The revision ID to make current . [ required ] --help Show this message and exit.","title":"set-current"},{"location":"cli/#serve","text":"Serve the current agent locally via a publicly-accessible URL. Usage: fixie agent serve [ OPTIONS ] [ PATH ] Options: -- host TEXT -- port INTEGER -- tunnel / -- no - tunnel ( default enabled ) Create a tunnel using localhost . run . -- reload / -- no - reload ( default enabled ) Reload automatically . -- venv / -- no - venv Run from virtual environment -- help Show this message and exit .","title":"serve"},{"location":"cli/#show","text":"Show an agent. Usage: fixie agent show [ OPTIONS ] AGENT_ID Options: -- help Show this message and exit .","title":"show"},{"location":"cli/#unpublish","text":"Make the current agent not public. Usage: fixie agent unpublish [ OPTIONS ] [ PATH ] Options: -- help Show this message and exit .","title":"unpublish"},{"location":"cli/#auth","text":"Authorizes fixie to access Fixie platform. Usage: fixie auth [ OPTIONS ] Options: -- force Forces authentication , even if the user is authenticated . -- help Show this message and exit .","title":"auth"},{"location":"cli/#deploy_1","text":"Deploy the current agent. Usage: fixie deploy [ OPTIONS ] [ PATH ] Options: -- metadata - only ( No longer supported . ) -- public Make the agent public . -- validate / -- no - validate ( default enabled ) Validate that the agent loads in a local venv before deploying . -- current / -- not - current ( default enabled ) Change the current revision to the deployed revision . -- metadata TEXT ... Additional metadata to associate with the revision . -- reindex / -- no - reindex Force any corpora to be reindexed . -- help Show this message and exit .","title":"deploy"},{"location":"cli/#init_1","text":"Creates an agent.yaml file. Usage: fixie init [ OPTIONS ] [ PATH ] Options: -- handle TEXT -- description TEXT -- entry - point TEXT -- more - info - url TEXT -- requirement TEXT Additional requirements for requirements . txt . Can be specified multiple times . -- help Show this message and exit .","title":"init"},{"location":"cli/#new","text":"Creates a new session and opens it. Usage: fixie new [ OPTIONS ] [ MESSAGE ] Options: -- web Open the session in the web interface . - a , -- agent TEXT A specific agent to talk to . If unset , `fixie` is used . - v , -- verbose Enable verbose output . -- help Show this message and exit .","title":"new"},{"location":"cli/#publish_1","text":"Make the current agent public. Usage: fixie publish [ OPTIONS ] [ PATH ] Options: -- help Show this message and exit .","title":"publish"},{"location":"cli/#query","text":"Runs a single query and exit. Usage: fixie query [ OPTIONS ] MESSAGE Options: -- web Open the session in the web interface . -- keep Do not delete the session after use . - v , -- verbose Enable verbose output . - a , -- agent TEXT A specific agent to talk to . If unset , `fixie` is used . -- help Show this message and exit .","title":"query"},{"location":"cli/#serve_1","text":"Serve the current agent locally via a publicly-accessible URL. Usage: fixie serve [ OPTIONS ] [ PATH ] Options: -- host TEXT -- port INTEGER -- tunnel / -- no - tunnel ( default enabled ) Create a tunnel using localhost . run . -- reload / -- no - reload ( default enabled ) Reload automatically . -- venv / -- no - venv Run from virtual environment -- help Show this message and exit .","title":"serve"},{"location":"cli/#session","text":"Session-related commands. Usage: fixie session [ OPTIONS ] COMMAND [ ARGS ] ... Options: -- help Show this message and exit .","title":"session"},{"location":"cli/#list_2","text":"Lists sessions. Usage: fixie session list [ OPTIONS ] Options: -- help Show this message and exit .","title":"list"},{"location":"cli/#new_1","text":"Creates a new session and opens it. Usage: fixie session new [ OPTIONS ] [ MESSAGE ] Options: -- web Open the session in the web interface . - a , -- agent TEXT A specific agent to talk to . If unset , `fixie` is used . - v , -- verbose Enable verbose output . -- help Show this message and exit .","title":"new"},{"location":"cli/#open","text":"Opens a session. Usage: fixie session open [ OPTIONS ] SESSION_ID [ MESSAGE ] Options: -- web Open the session in the web interface . - a , -- agent TEXT A specific agent to talk to . If unset , `fixie` is used . - v , -- verbose Enable verbose output . -- help Show this message and exit .","title":"open"},{"location":"cli/#query_1","text":"Runs a single query and exit. Usage: fixie session query [ OPTIONS ] MESSAGE Options: -- web Open the session in the web interface . -- keep Do not delete the session after use . - v , -- verbose Enable verbose output . - a , -- agent TEXT A specific agent to talk to . If unset , `fixie` is used . -- help Show this message and exit .","title":"query"},{"location":"cli/#unpublish_1","text":"Make the current agent not public. Usage: fixie unpublish [ OPTIONS ] [ PATH ] Options: -- help Show this message and exit .","title":"unpublish"},{"location":"cli/#user","text":"Displays information on the authenticated user. Usage: fixie user [ OPTIONS ] Options: -- help Show this message and exit .","title":"user"},{"location":"developer-preview/","text":"Welcome to the Fixie Developer Preview Welcome to Fixie! We're delighted to have you here. This brief overview will help you understand how things work and where to seek assistance if needed. We highly recommend joining our community on Discord , where the entire Fixie team is available to answer your questions and provide support. During the Developer Preview period, you can use Fixie for free, with a limit of 1,000 queries per day. If you require more queries or are interested in business use-cases, please contact us at hello@fixie.ai, and we will be happy to help. If you are new to Fixie, consider checking out our agent examples repo and explore the rest of the documentation on this site. Please note: as Fixie is continually evolving, you might encounter occasional bugs. We appreciate your feedback and will promptly address any issues. If you have a feature request, let us know! We love feature requests.","title":"Developer preview"},{"location":"developer-preview/#welcome-to-the-fixie-developer-preview","text":"Welcome to Fixie! We're delighted to have you here. This brief overview will help you understand how things work and where to seek assistance if needed. We highly recommend joining our community on Discord , where the entire Fixie team is available to answer your questions and provide support. During the Developer Preview period, you can use Fixie for free, with a limit of 1,000 queries per day. If you require more queries or are interested in business use-cases, please contact us at hello@fixie.ai, and we will be happy to help. If you are new to Fixie, consider checking out our agent examples repo and explore the rest of the documentation on this site. Please note: as Fixie is continually evolving, you might encounter occasional bugs. We appreciate your feedback and will promptly address any issues. If you have a feature request, let us know! We love feature requests.","title":"Welcome to the Fixie Developer Preview"},{"location":"docs-readme/","text":"To add a new theme run the following commands: poetry add theme-name just install just serve-docs Make sure the new theme name is used in mkdocs.yml file under theme/name. You should be able to checkout the docs on local page at http://127.0.0.1:8000/","title":"Docs readme"},{"location":"document-qa/","text":"Document Question and Answering Overview One of the most popular use cases for LLMs is doing question answering (Q/A) over a large corpus of unstructured data. Fixie makes it possible to quickly build Q/A Agents by automatically crawling a set of developer-provided URLs, generating embeddings, chunking the data, and storing it inside of a Vector Database for efficient retrieval. For data sets that aren't easily available to a web crawler, Fixie also supports custom corpora . To get started, let's look at a simple CodeShotAgent that answers questions about Python: import fixieai BASE_PROMPT = \"\"\"I am a helpful assistant that can answer questions \\ about Python. I try to be as concise as possible \\ in my answers while still effectively answering the question.\"\"\" URLS = [ \"https://docs.python.org/3.11/*\" ] DOCUMENTS = [ fixieai . DocumentCorpus ( urls = URLS )] agent = fixieai . CodeShotAgent ( BASE_PROMPT , [], DOCUMENTS , conversational = True ) You'll notice that we created a new variable, URLS , that contains an array of webpages that we would like Fixie to automatically crawl. (See Specifying URLs for detail about how this works.) Once we have our URLS , we instantiate a new CodeShotAgent with our BASE_PROMPT , an empty Few Shot array, a set of DOCUMENTS that point to our URLs, and whether we want a conversational Agent (conversational agents keep previous questions and answers in memory, so we recommend it for Q/A Agents). When a DocumentCorpus is provided, FewShots are optional (hence the empty array that we passed in). If you need FewShots, see Using Fewshots with Docs . Once ready, you can deploy your agent using fixie deploy . The agent will deploy immediately, but will not answer questions until indexing is complete. See Monitoring Indexing Status for more. Specifying URLs You can specify URLs in two forms: static or wildcard. Kind Example Use-case Static https://docs.python.org/3.11/tutorial/introduction.html Index only the specified URL. Wildcard https://docs.python.org/3.11/* Index the specified URL and all of its subpages. When you specify a wildcard, Fixie will: Crawl the site, respecting a sitemap if it exists. Limit the crawl to pages that start with the specified pattern. For example: # Wildcard pattern: https://foo.com/bar/* https :// foo . com / bar / index . html Links to -> https :// foo . com / bar / nested / index . html Links to -> https :// foo . com / bar / deep / nested / index . html These pages will be indexed . Links to -> https :// foo . com / index . html This page will not be indexed , because it doesn 't start with the wildcard pattern. Links to -> https://different-domain.com This page will not be indexed, because it doesn' t start with the wildcard pattern . Accessing Private URLs with Bearer Token In many cases, the set of documents that you want to access will be behind authentication. Fixie supports passing in a Bearer token with each request. To enable this, you'll define a new function that returns a token that will be passed in to the Authorization HTTP header as follows: Authorization: Bearer {your_token} . Here's an example: import fixieai BASE_PROMPT = \"\"\"I can answer questions from secret, non-public docs.\"\"\" URLS = [ \"https://private.myamazingsite.com/*\" ] CORPORA = [ fixieai . DocumentCorpus ( urls = URLS , auth_token_func = \"auth\" )] agent = fixieai . CodeShotAgent ( BASE_PROMPT , [], CORPORA , conversational = True ) # Don't forget to call @agent.register_func on your auth function @agent . register_func def auth (): return \"12345\" Custom Corpora If web crawling isn't a good fit for your use case, you can register a corpus function to load documents any way you need to. This allows for reading a private database for example. import fixieai from datetime import datetime BASE_PROMPT = \"\"\"I am a helpful assistant that can answer questions \\ about the contents of MyDatabase. I try to be as concise as possible \\ in my answers while still effectively answering the question.\"\"\" agents = fixieai . CodeShotAgent ( BASE_PROMPT , [], conversational = True ) class MyDatabasePageToken : read_timestamp : datetime offset : int = 0 def encode ( self ) -> str : # Serialize to a utf-8 encoded string pass @staticmethod def decode ( token : str ) -> MyDatabasePageToken : # Undo encode pass PAGE_SIZE = 20 @agent . register_corpus_func def load_my_database ( request : fixieai . CorpusRequest ) -> fixie . CorpusResponse : if not request . partition : initial_read = db_client . read ( \"MyTopLevelTable\" , keys_only = True ) first_page_token = MyDatabasePageToken ( initial_read . timestamp ()) partition_names = [ row . key for row in initial_read . results ] return fixieai . CorpusResponse ( partitions = [ fixieai . CorpusPartition ( name , first_page_token ) for name in partition_names ]) else : top_level_key = request . partition token = MyDatabasePageToken . decode ( request . page_token ) offset = token . offset * PAGE_SIZE read = db_client . read ( \"MyNestedTable\" , parent_key = top_level_key , limit = PAGE_SIZE , offset = offset , read_timestamp = token . read_timestamp ) docs = [ fixie . CorpusDocument ( row . key , row . my_column ) for row in read . results ] if read . has_more_results (): token . offset += 1 next_page_token = token . encode () else : next_page_token = None return fixieai . CorpusResponse ( page = fixieai . CorpusPage ( docs , next_page_token )) This example assumes an easily partitionable database with columns that already have text data, but there are way more options available. See CorpusRequest for more details. Using Fewshots with Docs By default, you don't need to use FewShots with Docs. Fixie's automatic behavior will produce a Q/A agent that meets the general need. If using FewShots, you'll need to manually tell Fixie to query the corpus using the built-in fixie_query_corpus function. Here's an example for an Agent that has access to docs about the primary plot points from HBO's Silicon Valley: FEW_SHOTS = \"\"\" Q: Who was Gilfoyle played by? Ask Func[fixie_query_corpus]: Who was Gilfoyle played by? Func[fixie_query_corpus] says: Gilfoyle was played by Martin Starr. A: Gilfoyle was played by Martin Starr. \"\"\" Excluding documents during crawl There are some cases where you don't want Fixie to crawl certain wepages or types of webpages when using the * wildcard pattern. In order to do this, you can supply a set of exclude_patterns , which are an array of regular expressions: import fixieai BASE_PROMPT = \"\"\"I answer questions based on the supplied corpus\"\"\" URLS = [ \"https://public.myamazingsite.com/*\" ] # Don't index any PDFs EXCLUDE_PATTERNS = [ \"*.pdf\" , ] CORPORA = [ fixieai . DocumentCorpus ( urls = URLS , exclude_patterns = EXCLUDE_PATTERNS )] agent = fixieai . CodeShotAgent ( BASE_PROMPT , [], CORPORA , conversational = True ) Supported file types File Type Extension Documents .doc , .docx , .ppt , .pptx PDFs .pdf Webpages .html Text .md , .txt , .rtf , Email .msg , .eml E-Books .epub Monitoring Indexing Status You can check the indexing status of your Agent by asking it any question. Your agent will return I'm still starting up. Please try again in a few minutes if it's still indexing. Indexing can take upwards of a few hours for very large data sets (smaller sets can be done in just a few minutes). Coming soon is the ability to see and manage your indexing directly on the Fixie dev console .","title":"Document Question and Answering"},{"location":"document-qa/#document-question-and-answering","text":"","title":"Document Question and Answering"},{"location":"document-qa/#overview","text":"One of the most popular use cases for LLMs is doing question answering (Q/A) over a large corpus of unstructured data. Fixie makes it possible to quickly build Q/A Agents by automatically crawling a set of developer-provided URLs, generating embeddings, chunking the data, and storing it inside of a Vector Database for efficient retrieval. For data sets that aren't easily available to a web crawler, Fixie also supports custom corpora . To get started, let's look at a simple CodeShotAgent that answers questions about Python: import fixieai BASE_PROMPT = \"\"\"I am a helpful assistant that can answer questions \\ about Python. I try to be as concise as possible \\ in my answers while still effectively answering the question.\"\"\" URLS = [ \"https://docs.python.org/3.11/*\" ] DOCUMENTS = [ fixieai . DocumentCorpus ( urls = URLS )] agent = fixieai . CodeShotAgent ( BASE_PROMPT , [], DOCUMENTS , conversational = True ) You'll notice that we created a new variable, URLS , that contains an array of webpages that we would like Fixie to automatically crawl. (See Specifying URLs for detail about how this works.) Once we have our URLS , we instantiate a new CodeShotAgent with our BASE_PROMPT , an empty Few Shot array, a set of DOCUMENTS that point to our URLs, and whether we want a conversational Agent (conversational agents keep previous questions and answers in memory, so we recommend it for Q/A Agents). When a DocumentCorpus is provided, FewShots are optional (hence the empty array that we passed in). If you need FewShots, see Using Fewshots with Docs . Once ready, you can deploy your agent using fixie deploy . The agent will deploy immediately, but will not answer questions until indexing is complete. See Monitoring Indexing Status for more.","title":"Overview"},{"location":"document-qa/#specifying-urls","text":"You can specify URLs in two forms: static or wildcard. Kind Example Use-case Static https://docs.python.org/3.11/tutorial/introduction.html Index only the specified URL. Wildcard https://docs.python.org/3.11/* Index the specified URL and all of its subpages. When you specify a wildcard, Fixie will: Crawl the site, respecting a sitemap if it exists. Limit the crawl to pages that start with the specified pattern. For example: # Wildcard pattern: https://foo.com/bar/* https :// foo . com / bar / index . html Links to -> https :// foo . com / bar / nested / index . html Links to -> https :// foo . com / bar / deep / nested / index . html These pages will be indexed . Links to -> https :// foo . com / index . html This page will not be indexed , because it doesn 't start with the wildcard pattern. Links to -> https://different-domain.com This page will not be indexed, because it doesn' t start with the wildcard pattern .","title":"Specifying URLs"},{"location":"document-qa/#accessing-private-urls-with-bearer-token","text":"In many cases, the set of documents that you want to access will be behind authentication. Fixie supports passing in a Bearer token with each request. To enable this, you'll define a new function that returns a token that will be passed in to the Authorization HTTP header as follows: Authorization: Bearer {your_token} . Here's an example: import fixieai BASE_PROMPT = \"\"\"I can answer questions from secret, non-public docs.\"\"\" URLS = [ \"https://private.myamazingsite.com/*\" ] CORPORA = [ fixieai . DocumentCorpus ( urls = URLS , auth_token_func = \"auth\" )] agent = fixieai . CodeShotAgent ( BASE_PROMPT , [], CORPORA , conversational = True ) # Don't forget to call @agent.register_func on your auth function @agent . register_func def auth (): return \"12345\"","title":"Accessing Private URLs with Bearer Token"},{"location":"document-qa/#custom-corpora","text":"If web crawling isn't a good fit for your use case, you can register a corpus function to load documents any way you need to. This allows for reading a private database for example. import fixieai from datetime import datetime BASE_PROMPT = \"\"\"I am a helpful assistant that can answer questions \\ about the contents of MyDatabase. I try to be as concise as possible \\ in my answers while still effectively answering the question.\"\"\" agents = fixieai . CodeShotAgent ( BASE_PROMPT , [], conversational = True ) class MyDatabasePageToken : read_timestamp : datetime offset : int = 0 def encode ( self ) -> str : # Serialize to a utf-8 encoded string pass @staticmethod def decode ( token : str ) -> MyDatabasePageToken : # Undo encode pass PAGE_SIZE = 20 @agent . register_corpus_func def load_my_database ( request : fixieai . CorpusRequest ) -> fixie . CorpusResponse : if not request . partition : initial_read = db_client . read ( \"MyTopLevelTable\" , keys_only = True ) first_page_token = MyDatabasePageToken ( initial_read . timestamp ()) partition_names = [ row . key for row in initial_read . results ] return fixieai . CorpusResponse ( partitions = [ fixieai . CorpusPartition ( name , first_page_token ) for name in partition_names ]) else : top_level_key = request . partition token = MyDatabasePageToken . decode ( request . page_token ) offset = token . offset * PAGE_SIZE read = db_client . read ( \"MyNestedTable\" , parent_key = top_level_key , limit = PAGE_SIZE , offset = offset , read_timestamp = token . read_timestamp ) docs = [ fixie . CorpusDocument ( row . key , row . my_column ) for row in read . results ] if read . has_more_results (): token . offset += 1 next_page_token = token . encode () else : next_page_token = None return fixieai . CorpusResponse ( page = fixieai . CorpusPage ( docs , next_page_token )) This example assumes an easily partitionable database with columns that already have text data, but there are way more options available. See CorpusRequest for more details.","title":"Custom Corpora"},{"location":"document-qa/#using-fewshots-with-docs","text":"By default, you don't need to use FewShots with Docs. Fixie's automatic behavior will produce a Q/A agent that meets the general need. If using FewShots, you'll need to manually tell Fixie to query the corpus using the built-in fixie_query_corpus function. Here's an example for an Agent that has access to docs about the primary plot points from HBO's Silicon Valley: FEW_SHOTS = \"\"\" Q: Who was Gilfoyle played by? Ask Func[fixie_query_corpus]: Who was Gilfoyle played by? Func[fixie_query_corpus] says: Gilfoyle was played by Martin Starr. A: Gilfoyle was played by Martin Starr. \"\"\"","title":"Using Fewshots with Docs"},{"location":"document-qa/#excluding-documents-during-crawl","text":"There are some cases where you don't want Fixie to crawl certain wepages or types of webpages when using the * wildcard pattern. In order to do this, you can supply a set of exclude_patterns , which are an array of regular expressions: import fixieai BASE_PROMPT = \"\"\"I answer questions based on the supplied corpus\"\"\" URLS = [ \"https://public.myamazingsite.com/*\" ] # Don't index any PDFs EXCLUDE_PATTERNS = [ \"*.pdf\" , ] CORPORA = [ fixieai . DocumentCorpus ( urls = URLS , exclude_patterns = EXCLUDE_PATTERNS )] agent = fixieai . CodeShotAgent ( BASE_PROMPT , [], CORPORA , conversational = True )","title":"Excluding documents during crawl"},{"location":"document-qa/#supported-file-types","text":"File Type Extension Documents .doc , .docx , .ppt , .pptx PDFs .pdf Webpages .html Text .md , .txt , .rtf , Email .msg , .eml E-Books .epub","title":"Supported file types"},{"location":"document-qa/#monitoring-indexing-status","text":"You can check the indexing status of your Agent by asking it any question. Your agent will return I'm still starting up. Please try again in a few minutes if it's still indexing. Indexing can take upwards of a few hours for very large data sets (smaller sets can be done in just a few minutes). Coming soon is the ability to see and manage your indexing directly on the Fixie dev console .","title":"Monitoring Indexing Status"},{"location":"langchain/","text":"Deploying LangChain Agents on Fixie Overview LangChain is a popular framework for developing applications built on top of Large Language Models. Fixie supports LangChain as a first-class citizen. This means you can develop LangChain Agents/Chains/Prompts just as you typically would and then quickly deploy them onto Fixie infrastructure. Why Deploy on Fixie? Deploying on Fixie gives you three major advantages: We host it for you (for free). Simply run fixie deploy and your Agent will be hosted in the cloud, complete with a REST API for calling it programatically and a shareable URL that will allow others to demo your agent in the browser. No need for an OpenAI key. Fixie will automatically take care of that, and supports 1,000 free requests per day, per user. So if your creation gets popular, you're not stuck footing the bill or asking people to mint their own key. It allows you to integrate with the rest of the Fixie ecosystem. This means other people in the community will be able to leverage your agent and vice-versa. Getting Started First, you'll make to make sure you have installed the Fixie CLI and have authenticated to Fixie (these are necessary for deploying to Fixie): Install Fixie on your machine: pip install fixieai Create an account and link your command line to it: fixie auth Next, you'll need to tell Fixie what function to call to invoke your app. As an example, let's imagine something as simple as a PromptTemplate : from langchain.prompts import PromptTemplate from langchain.llms import OpenAI from langchain.chains import LLMChain llm = OpenAI ( temperature = 0.9 ) prompt = PromptTemplate ( input_variables = [ \"product\" ], template = \"What is a good name for a company that makes {product} ?\" , ) chain = LLMChain ( llm = llm , prompt = prompt ) chain . run ( \"colorful socks\" ) In the above example, we're calling chain.run() directly inside of our code with a hardcoded value of \"colorful socks\". This isn't that useful, since it means we can only get company names for colorful socks! Instead, we want a user to be able to provide the variable themselves, and we want Fixie to pass that to us. To accomplish this, we're going to wrap chain.run() inside of a func. Here's our new version: # main.py from langchain.prompts import PromptTemplate from langchain.llms import OpenAI from langchain.chains import LLMChain llm = OpenAI ( temperature = 0.9 ) prompt = PromptTemplate ( input_variables = [ \"product\" ], template = \"What is a good name for a company that makes {product} ?\" , ) chain = LLMChain ( llm = llm , prompt = prompt ) def invoke_chain ( input ): return chain . run ( input ) Instead of calling chain.run() directly, we've instead wrapped it inside of a function called invoke_chain that takes a single str as an input variable. We then pass that string directly to our chain.run() . Now we need to tell Fixie about our Chain. To do this, run fixie init . Fixie will ask you a few questions about your agent like its handle (its name inside of Fixie) and description (this helps others understand how to use your creation). The most important part is the Entry Point . This is where you tell Fixie where to find your function. The format is name_of_your_python_file:name_of_your_function . In our case, our file is main.py , so we'll put main:invoke_chain . Once you've done this, Fixie will create an agent.yaml file in the same directory. You can edit this any time. You'll also notice that Fixie automatically created a requirements.txt file. If you're not familiar with requirements.txt , it's a simple way to define the module requirements for your project. Fixie will automatically install these on deploy. In our example, we need the following setup: # requirements.txt langchain openai fixieai Now we're ready to deploy! Run fixie deploy and Fixie takes care of the rest. Feel free to make changes and re-deploy. When you're ready to make your agent public (so others can access it) simply change published to true in your agent.yaml file and run fixie deploy again. Developing and testing your Agent When you're iteratively developing your agent, the fastest feedback loop is to run it locally, rather than re-deploying to Fixie on every change. To do this, run fixie serve . This will create a tunnel between your machine and Fixie, allowing you to test on Fixie but debug locally on your machine. Calling your Agent via API Once your agent is deployed, Fixie automatically provides you with a REST API: curl \"https://app.fixie.ai/api/agents/{username}/{agent_name}\" \\ -d \"{ 'message': {'text': 'colorful socks' }}\" \\ -H \"Authorization: Bearer {your_api_token}\" \\ -H \"Content-Type: application/json\" You can get your Fixie API Token from your profile page .","title":"Using Langchain"},{"location":"langchain/#deploying-langchain-agents-on-fixie","text":"","title":"Deploying LangChain Agents on Fixie"},{"location":"langchain/#overview","text":"LangChain is a popular framework for developing applications built on top of Large Language Models. Fixie supports LangChain as a first-class citizen. This means you can develop LangChain Agents/Chains/Prompts just as you typically would and then quickly deploy them onto Fixie infrastructure.","title":"Overview"},{"location":"langchain/#why-deploy-on-fixie","text":"Deploying on Fixie gives you three major advantages: We host it for you (for free). Simply run fixie deploy and your Agent will be hosted in the cloud, complete with a REST API for calling it programatically and a shareable URL that will allow others to demo your agent in the browser. No need for an OpenAI key. Fixie will automatically take care of that, and supports 1,000 free requests per day, per user. So if your creation gets popular, you're not stuck footing the bill or asking people to mint their own key. It allows you to integrate with the rest of the Fixie ecosystem. This means other people in the community will be able to leverage your agent and vice-versa.","title":"Why Deploy on Fixie?"},{"location":"langchain/#getting-started","text":"First, you'll make to make sure you have installed the Fixie CLI and have authenticated to Fixie (these are necessary for deploying to Fixie): Install Fixie on your machine: pip install fixieai Create an account and link your command line to it: fixie auth Next, you'll need to tell Fixie what function to call to invoke your app. As an example, let's imagine something as simple as a PromptTemplate : from langchain.prompts import PromptTemplate from langchain.llms import OpenAI from langchain.chains import LLMChain llm = OpenAI ( temperature = 0.9 ) prompt = PromptTemplate ( input_variables = [ \"product\" ], template = \"What is a good name for a company that makes {product} ?\" , ) chain = LLMChain ( llm = llm , prompt = prompt ) chain . run ( \"colorful socks\" ) In the above example, we're calling chain.run() directly inside of our code with a hardcoded value of \"colorful socks\". This isn't that useful, since it means we can only get company names for colorful socks! Instead, we want a user to be able to provide the variable themselves, and we want Fixie to pass that to us. To accomplish this, we're going to wrap chain.run() inside of a func. Here's our new version: # main.py from langchain.prompts import PromptTemplate from langchain.llms import OpenAI from langchain.chains import LLMChain llm = OpenAI ( temperature = 0.9 ) prompt = PromptTemplate ( input_variables = [ \"product\" ], template = \"What is a good name for a company that makes {product} ?\" , ) chain = LLMChain ( llm = llm , prompt = prompt ) def invoke_chain ( input ): return chain . run ( input ) Instead of calling chain.run() directly, we've instead wrapped it inside of a function called invoke_chain that takes a single str as an input variable. We then pass that string directly to our chain.run() . Now we need to tell Fixie about our Chain. To do this, run fixie init . Fixie will ask you a few questions about your agent like its handle (its name inside of Fixie) and description (this helps others understand how to use your creation). The most important part is the Entry Point . This is where you tell Fixie where to find your function. The format is name_of_your_python_file:name_of_your_function . In our case, our file is main.py , so we'll put main:invoke_chain . Once you've done this, Fixie will create an agent.yaml file in the same directory. You can edit this any time. You'll also notice that Fixie automatically created a requirements.txt file. If you're not familiar with requirements.txt , it's a simple way to define the module requirements for your project. Fixie will automatically install these on deploy. In our example, we need the following setup: # requirements.txt langchain openai fixieai Now we're ready to deploy! Run fixie deploy and Fixie takes care of the rest. Feel free to make changes and re-deploy. When you're ready to make your agent public (so others can access it) simply change published to true in your agent.yaml file and run fixie deploy again.","title":"Getting Started"},{"location":"langchain/#developing-and-testing-your-agent","text":"When you're iteratively developing your agent, the fastest feedback loop is to run it locally, rather than re-deploying to Fixie on every change. To do this, run fixie serve . This will create a tunnel between your machine and Fixie, allowing you to test on Fixie but debug locally on your machine.","title":"Developing and testing your Agent"},{"location":"langchain/#calling-your-agent-via-api","text":"Once your agent is deployed, Fixie automatically provides you with a REST API: curl \"https://app.fixie.ai/api/agents/{username}/{agent_name}\" \\ -d \"{ 'message': {'text': 'colorful socks' }}\" \\ -H \"Authorization: Bearer {your_api_token}\" \\ -H \"Content-Type: application/json\" You can get your Fixie API Token from your profile page .","title":"Calling your Agent via API"},{"location":"python-agent-api/","text":"Fixie Agent Python API Reference This module holds objects that represent the API interface by which Agents talk to Fixie ecosystem. AgentError An error that occurred in the process of generating a response. Source code in fixieai/agents/api.py 72 73 74 75 76 77 78 79 80 81 82 83 @pydantic_dataclasses . dataclass class AgentError : \"\"\"An error that occurred in the process of generating a response.\"\"\" # A code representing the error. code : str # A message describing the error that will be displayed to the user. message : str # Additional debugging context from the error. details : Optional [ Dict ] AgentQuery A standalone query sent to a Fixie agent. Source code in fixieai/agents/api.py 58 59 60 61 62 63 64 65 66 67 68 69 @pydantic_dataclasses . dataclass class AgentQuery : \"\"\"A standalone query sent to a Fixie agent.\"\"\" # The contents of the query. message : Message # This is an access token associated with the user for whom this query was # created. Agents wishing to make queries to other agents, or to other # Fixie services, should carry this token in the query so that it # can be tied back to the original user. access_token : Optional [ str ] = None AgentResponse A response message from an Agent. Source code in fixieai/agents/api.py 86 87 88 89 90 91 92 93 94 95 @pydantic_dataclasses . dataclass class AgentResponse : \"\"\"A response message from an Agent.\"\"\" # The text of the response message. message : Message # Error details, if an error occurred generating the response. Note that `message` should still be included, # but may indicate that an error occurred that prevented the agent from fully handling the request. error : Optional [ AgentError ] = None Embed An Embed represents a binary object attached to a Message. Source code in fixieai/agents/api.py 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 @pydantic_dataclasses . dataclass class Embed : \"\"\"An Embed represents a binary object attached to a Message.\"\"\" # The MIME content type of the object, e.g., \"image/png\" or \"application/json\". content_type : str # A public URL where the object can be downloaded. This can be a data URI. uri : str @property def content ( self ) -> bytes : \"\"\"Retrieves the content for this Embed object.\"\"\" if self . uri . startswith ( \"data:\" ): return base64 . b64decode ( self . uri . split ( \",\" )[ 1 ]) return requests . get ( self . uri ) . content @content . setter def content ( self , content : bytes ): \"\"\"Sets the content of the Embed object as a data URI.\"\"\" self . uri = f \"data:base64, { base64 . b64encode ( content ) . decode ( 'utf-8' ) } \" @property def text ( self ) -> str : \"\"\"Retrieves the content of the Embed object as a string.\"\"\" return self . content . decode ( \"utf-8\" ) @text . setter def text ( self , text : str ): \"\"\"Sets the content of the Embed object as a string.\"\"\" self . content = text . encode ( \"utf-8\" ) content : bytes property writable Retrieves the content for this Embed object. text : str property writable Retrieves the content of the Embed object as a string. Message A Message represents a single message sent to a Fixie agent. Source code in fixieai/agents/api.py 47 48 49 50 51 52 53 54 55 @pydantic_dataclasses . dataclass class Message : \"\"\"A Message represents a single message sent to a Fixie agent.\"\"\" # The text of the message. text : str # A mapping of embed keys to Embed objects. embeds : Dict [ str , Embed ] = dataclasses . field ( default_factory = dict ) CodeShotAgent Bases: agent_base . AgentBase A CodeShot agent. To make a CodeShot agent, simply pass a BASE_PROMPT and FEW_SHOTS: BASE_PROMPT = \"A summary of what this agent does; how it does it; and its personality \" FEW_SHOTS = ''' Q: <Sample query that this agent supports> A: <Desired response for this query> Q: <Another sample query> A: <Desired response for this query> ''' agent = CodeShotAgent(BASE_PROMPT, FEW_SHOTS) You can have FEW_SHOTS as a single string of all your few-shots separated by 2 new lines, or as an explicit list of one few-shot per index. Your few-shots may reach out to other Agents in the fixie ecosystem by \"Ask Agent[agent_id]: \", or reach out to some python functions by \"Ask Func[func_name]: \". There are a series of default runtime Func s provided by the platform available for your agents to consume. For a full list of default runtime Func s, refer to: http://docs.fixie.ai/XXX You may also need to write your own python functions here to be consumed by your agent. To make a function accessible by an agent, you'd need to register it by @agent.register_func . Example: @agent.register_func def func_name ( query : fixieai . Message ) -> ReturnType : ... , where ReturnType is one of `str` , `fixieai.Message` , or `fixie.AgentResponse` . Note that in the above, we are using the decorator @agent.register_func to register this function with the agent instance we just created. To check out the default Func s that are provided in Fixie, see: http://docs.fixie.ai/XXX Source code in fixieai/agents/code_shot.py 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 class CodeShotAgent ( agent_base . AgentBase ): \"\"\"A CodeShot agent. To make a CodeShot agent, simply pass a BASE_PROMPT and FEW_SHOTS: BASE_PROMPT = \"A summary of what this agent does; how it does it; and its personality\" FEW_SHOTS = ''' Q: <Sample query that this agent supports> A: <Desired response for this query> Q: <Another sample query> A: <Desired response for this query> ''' agent = CodeShotAgent(BASE_PROMPT, FEW_SHOTS) You can have FEW_SHOTS as a single string of all your few-shots separated by 2 new lines, or as an explicit list of one few-shot per index. Your few-shots may reach out to other Agents in the fixie ecosystem by \"Ask Agent[agent_id]: <query to pass>\", or reach out to some python functions by \"Ask Func[func_name]: <query to pass>\". There are a series of default runtime `Func`s provided by the platform available for your agents to consume. For a full list of default runtime `Func`s, refer to: http://docs.fixie.ai/XXX You may also need to write your own python functions here to be consumed by your agent. To make a function accessible by an agent, you'd need to register it by `@agent.register_func`. Example: @agent.register_func def func_name(query: fixieai.Message) -> ReturnType: ... , where ReturnType is one of `str`, `fixieai.Message`, or `fixie.AgentResponse`. Note that in the above, we are using the decorator `@agent.register_func` to register this function with the agent instance we just created. To check out the default `Func`s that are provided in Fixie, see: http://docs.fixie.ai/XXX \"\"\" def __init__ ( self , base_prompt : str , few_shots : Union [ str , List [ str ]], corpora : Optional [ List [ corpora . UrlDocumentCorpus ]] = None , conversational : bool = False , oauth_params : Optional [ oauth . OAuthParams ] = None , llm_settings : Optional [ llm_settings . LlmSettings ] = None , ): super () . __init__ ( oauth_params ) if isinstance ( few_shots , str ): few_shots = _split_few_shots ( few_shots ) self . base_prompt = base_prompt self . few_shots = few_shots self . url_corpora = corpora self . conversational = conversational self . llm_settings = llm_settings utils . strip_prompt_lines ( self ) @property def corpora ( self ): url_corpora = self . url_corpora or [] custom_corpora = [ corpora . CustomCorpus ( func_name = f ) for f in self . _corpus_funcs . keys () ] return url_corpora + custom_corpora if url_corpora or custom_corpora else None def metadata ( self ) -> metadata . Metadata : return metadata . CodeShotAgentMetadata ( self . base_prompt , self . few_shots , self . corpora , self . conversational , self . llm_settings , ) def validate ( self ): utils . validate_code_shot_agent ( self ) CorpusDocument Some meaningful item of data from a corpus. This could be an HTML page, a PDF, or a raw string of text (among others). Fixie will handle parsing and chunking this document so that appropriately sized chunks can be included in LLM requests. Note: If custom parsing is desired, agents are free to implement their own parsing to return documents with text/plain mime_types instead of whatever they fetch natively. Fixie will not alter text/plain documents prior to chunking. Source code in fixieai/agents/corpora.py 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 @pydantic_dataclasses . dataclass class CorpusDocument : \"\"\"Some meaningful item of data from a corpus. This could be an HTML page, a PDF, or a raw string of text (among others). Fixie will handle parsing and chunking this document so that appropriately sized chunks can be included in LLM requests. Note: If custom parsing is desired, agents are free to implement their own parsing to return documents with text/plain mime_types instead of whatever they fetch natively. Fixie will not alter text/plain documents prior to chunking.\"\"\" source_name : str content : bytes = dataclasses . field ( metadata = dataclasses_json . config ( encoder = lambda c : base64 . b64encode ( c ) . decode (), decoder = lambda c : base64 . b64decode ( c . encode ()), ) ) encoding : str = \"UTF-8\" mime_type : str = \"text/plain\" @property def text ( self ) -> str : return self . content . decode ( self . encoding ) CorpusPage A page of CorpusDocuments. In addition to the documents themselves, a page may include a continuation token for fetching the next page (in the same partition). Omitting a token implies that this is the last page. Source code in fixieai/agents/corpora.py 127 128 129 130 131 132 133 134 @pydantic_dataclasses . dataclass class CorpusPage : \"\"\"A page of CorpusDocuments. In addition to the documents themselves, a page may include a continuation token for fetching the next page (in the same partition). Omitting a token implies that this is the last page.\"\"\" documents : List [ CorpusDocument ] next_page_token : Optional [ str ] = None CorpusPartition An identifier for a subset of a corpus, along with an optional token to use when loading its first page. Each partition will only be loaded once during a single crawl. If multiple responses include the same partition, the token of the first received response will be used. Source code in fixieai/agents/corpora.py 89 90 91 92 93 94 95 96 97 @pydantic_dataclasses . dataclass class CorpusPartition : \"\"\"An identifier for a subset of a corpus, along with an optional token to use when loading its first page. Each partition will only be loaded once during a single crawl. If multiple responses include the same partition, the token of the first received response will be used.\"\"\" partition : str first_page_token : Optional [ str ] = None CorpusRequest Bases: dataclasses_json . DataClassJsonMixin A request for some piece of the agent's corpus. In addition to returning documents, each response may expand the corpus space in one or both of two dimensions: new partitions and next pages. Partitions are non-overlapping subsets of a corpus which may be loaded in parallel by Fixie. A response's new partitions will be ignored if previously included in another response. When a response includes a page of documents, that page may indicate that another page is available in the same partition. Pages are always loaded serially in order. The partition is completed when a response has a page with no next_page_token. Agents will always receive a first request with the default (unnamed) partition and no page_token. Subsequent requests depend on prior responses and will always include at least one of those fields. Examples: Simple handful of documents: When receiving the initial request , the agent responds with a page of documents . This could include a next_page_token for more documents in the single default partition if needed . Web crawl: Each URL corresponds to a partition and the agent never returns tokens . The initial response only includes partitions , one for each root URL to crawl . Each subsequent request includes the partition ( the URL ) and the corresponding response contains a page with a single document - the resource at that URL . If the document links to other resources that should be included in the corpus , the response also contains those URLs as new partitions . The process repeats for all partitions until there are no known incomplete partitions or until crawl limits are reached . Database: Consider a database with a parent table keyed by parent_id and an interleaved child table keyed by ( parent_id , child_id ) whose rows correspond to corpus documents . This agent will use tokens that encode a read timestamp ( for consistency ) and an offset to be used in combination with a static page size . Upon receiving the initial CorpusRequest , the agent chooses a commit timestamp to use for all reads and returns a partition for each parent_id along with a first_page_token indicating the chosen read timestamp and an offset of 0 . For each partition , the agent then receives requests with the partition ( a parent_id ) and a page token ( the read timestamp and offest ) . It responds with documents corresponding to the next page size child rows within the given parent . If more children exist , the response includes a next_page_token with the same read timestamp and an incremented offset . This repeats until there are no more children , at which point the response has no next_page_token and the partition is complete . Note : Including multiple parent_ids in each partition would also work and would be an effective way to limit parallelism if desired . Attributes: partition ( Optional [ str ] ) \u2013 The partition of the corpus that should be read. This will be empty for the initial request, indicating the default partition. For subsequent requests, it will either be the name of a partition returned by a previous request or empty if the default partition contains multiple pages for this agent. page_token ( Optional [ str ] ) \u2013 A token for paginating results within a corpus partition. If present, this will be echoed from a previous response. Source code in fixieai/agents/corpora.py 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 @pydantic_dataclasses . dataclass class CorpusRequest ( dataclasses_json . DataClassJsonMixin ): \"\"\"A request for some piece of the agent's corpus. In addition to returning documents, each response may expand the corpus space in one or both of two dimensions: new partitions and next pages. Partitions are non-overlapping subsets of a corpus which may be loaded in parallel by Fixie. A response's new partitions will be ignored if previously included in another response. When a response includes a page of documents, that page may indicate that another page is available in the same partition. Pages are always loaded serially in order. The partition is completed when a response has a page with no next_page_token. Agents will always receive a first request with the default (unnamed) partition and no page_token. Subsequent requests depend on prior responses and will always include at least one of those fields. Examples: Simple handful of documents: When receiving the initial request, the agent responds with a page of documents. This could include a next_page_token for more documents in the single default partition if needed. Web crawl: Each URL corresponds to a partition and the agent never returns tokens. The initial response only includes partitions, one for each root URL to crawl. Each subsequent request includes the partition (the URL) and the corresponding response contains a page with a single document - the resource at that URL. If the document links to other resources that should be included in the corpus, the response also contains those URLs as new partitions. The process repeats for all partitions until there are no known incomplete partitions or until crawl limits are reached. Database: Consider a database with a parent table keyed by parent_id and an interleaved child table keyed by (parent_id, child_id) whose rows correspond to corpus documents. This agent will use tokens that encode a read timestamp (for consistency) and an offset to be used in combination with a static page size. Upon receiving the initial CorpusRequest, the agent chooses a commit timestamp to use for all reads and returns a partition for each parent_id along with a first_page_token indicating the chosen read timestamp and an offset of 0. For each partition, the agent then receives requests with the partition (a parent_id) and a page token (the read timestamp and offest). It responds with documents corresponding to the next page size child rows within the given parent. If more children exist, the response includes a next_page_token with the same read timestamp and an incremented offset. This repeats until there are no more children, at which point the response has no next_page_token and the partition is complete. Note: Including multiple parent_ids in each partition would also work and would be an effective way to limit parallelism if desired. Attributes: partition: The partition of the corpus that should be read. This will be empty for the initial request, indicating the default partition. For subsequent requests, it will either be the name of a partition returned by a previous request or empty if the default partition contains multiple pages for this agent. page_token: A token for paginating results within a corpus partition. If present, this will be echoed from a previous response. \"\"\" partition : Optional [ str ] = None page_token : Optional [ str ] = None CorpusResponse Bases: dataclasses_json . DataClassJsonMixin A response to a CorpusRequest. See CorpusRequest for details. Source code in fixieai/agents/corpora.py 137 138 139 140 141 142 @pydantic_dataclasses . dataclass class CorpusResponse ( dataclasses_json . DataClassJsonMixin ): \"\"\"A response to a CorpusRequest. See CorpusRequest for details.\"\"\" partitions : Optional [ List [ CorpusPartition ]] = None page : Optional [ CorpusPage ] = None CustomCorpus A custom corpus for a Fixie CodeShot Agent. This uses a registered corpus func to load documents from an arbitrary source. Source code in fixieai/agents/corpora.py 145 146 147 148 149 150 @pydantic_dataclasses . dataclass class CustomCorpus : \"\"\"A custom corpus for a Fixie CodeShot Agent. This uses a registered corpus func to load documents from an arbitrary source.\"\"\" func_name : str DocumentLoader Deprecated. This doesn't do anything. Source code in fixieai/agents/corpora.py 153 154 155 156 157 158 @deprecated ( reason = \"Use register_corpus_func for custom document loading.\" ) @pydantic_dataclasses . dataclass class DocumentLoader : \"\"\"Deprecated. This doesn't do anything.\"\"\" name : str UrlDocumentCorpus URL Document corpus for a Fixie CodeShot Agent. Source code in fixieai/agents/corpora.py 161 162 163 164 165 166 167 168 169 170 171 172 173 174 @pydantic_dataclasses . dataclass class UrlDocumentCorpus : \"\"\"URL Document corpus for a Fixie CodeShot Agent.\"\"\" urls : List [ str ] \"\"\"URLs to load documents from. A trailing wildcard (e.g., https://example.com/*), can be used to load all documents from a site.\"\"\" exclude_patterns : Optional [ List [ str ]] = None \"\"\"A list of wildcard patterns to exclude from crawled URLs (e.g., */no_crawl/*).\"\"\" auth_token_func : Optional [ str ] = None loader : Optional [ DocumentLoader ] = None # Deprecated. exclude_patterns : Optional [ List [ str ]] = None instance-attribute class-attribute A list of wildcard patterns to exclude from crawled URLs (e.g., /no_crawl/ ). urls : List [ str ] instance-attribute URLs to load documents from. A trailing wildcard (e.g., https://example.com/*), can be used to load all documents from a site. OAuthHandler OAuthHandler that wraps around a (OAuthParams, query) to authenticate. This client object provides 3 main method credentials: Returns current user's OAuth access token, or None if they are not authenticated. get_authorization_url: Returns a url that the users can click to authenticate themselves. authorize: Exchanges a received access code (from auth redirect callback) for an access token. If successful, user's storage is updated. Source code in fixieai/agents/oauth.py 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 class OAuthHandler : \"\"\" OAuthHandler that wraps around a (OAuthParams, query) to authenticate. This client object provides 3 main method: * credentials: Returns current user's OAuth access token, or None if they are not authenticated. * get_authorization_url: Returns a url that the users can click to authenticate themselves. * authorize: Exchanges a received access code (from auth redirect callback) for an access token. If successful, user's storage is updated. \"\"\" # OAuth keys reserved in UserStorage OAUTH_STATE_KEY = \"_oauth_state\" OAUTH_TOKEN_KEY = \"_oauth_token\" def __init__ ( self , oauth_params : OAuthParams , token_claims : token . VerifiedTokenClaims , ): self . _storage = user_storage . UserStorage ( token_claims ) self . _oauth_params = oauth_params self . _agent_id = token_claims . agent_id def get_authorization_url ( self ) -> str : \"\"\"Returns a URL to launch the authorization flow.\"\"\" auth_state = f \" { self . _agent_id } : { secrets . token_urlsafe () } \" data = { \"response_type\" : \"code\" , \"access_type\" : \"offline\" , \"client_id\" : self . _oauth_params . client_id , \"scope\" : \" \" . join ( self . _oauth_params . scopes ), \"state\" : auth_state , \"redirect_uri\" : constants . FIXIE_OAUTH_REDIRECT_URL , } url = self . _oauth_params . auth_uri + \"?\" + parse . urlencode ( data ) # Store auth_state in UserStorage for validation later. self . _storage [ self . OAUTH_STATE_KEY ] = auth_state return url def user_token ( self ) -> Optional [ str ]: \"\"\"Returns current user's OAuth credentials, or None if not authorized.\"\"\" try : creds_json = self . _storage [ self . OAUTH_TOKEN_KEY ] except KeyError : return None if not isinstance ( creds_json , str ): logging . warning ( f \"Value at user_storage[ { self . OAUTH_TOKEN_KEY !r} ] is \" f \"not an OAuthCredentials json: { creds_json !r} \" ) del self . _storage [ self . OAUTH_TOKEN_KEY ] return None try : creds = _OAuthCredentials . from_json ( creds_json ) except ( TypeError , LookupError , ValueError ): logging . warning ( f \"Value at user_storage[ { self . OAUTH_TOKEN_KEY !r} ] is \" f \"not a valid _OAuthCredentials json: { creds_json !r} \" ) del self . _storage [ self . OAUTH_TOKEN_KEY ] return None if creds . expired : logging . debug ( f \"Credentials expired at { creds . expiry } \" ) if not creds . refresh_token : logging . warning ( \"No refresh token available\" ) return None logging . debug ( \"Refreshing credentials...\" ) creds . refresh ( self . _oauth_params ) self . _save_credentials ( creds ) # Save refreshed token to UserStorage return creds . access_token def authorize ( self , state : str , code : str ): \"\"\"Authorize the received access `code` against the client secret. If successful, the credentials will be saved in user storage. \"\"\" expected_state = self . _storage [ self . OAUTH_STATE_KEY ] if state != expected_state : logging . warning ( f \"Unknown state token, expected: { expected_state !r} actual: { state !r} \" ) raise ValueError ( f \"Unknown state token\" ) data = { \"grant_type\" : \"authorization_code\" , \"client_id\" : self . _oauth_params . client_id , \"client_secret\" : self . _oauth_params . client_secret , \"code\" : code , \"redirect_uri\" : constants . FIXIE_OAUTH_REDIRECT_URL , } response = _send_authorize_request ( self . _oauth_params . token_uri , data ) logging . debug ( f \"OAuth auth request succeeded, lifetime= { response . expires_in } \" f \"refreshable= { response . refresh_token is not None } \" ) credentials = _OAuthCredentials ( response . access_token , _get_expiry ( response . expires_in ), response . refresh_token , ) self . _save_credentials ( credentials ) def _save_credentials ( self , credentials : \"_OAuthCredentials\" ): self . _storage [ self . OAUTH_TOKEN_KEY ] = credentials . to_json () authorize ( state , code ) Authorize the received access code against the client secret. If successful, the credentials will be saved in user storage. Source code in fixieai/agents/oauth.py 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 def authorize ( self , state : str , code : str ): \"\"\"Authorize the received access `code` against the client secret. If successful, the credentials will be saved in user storage. \"\"\" expected_state = self . _storage [ self . OAUTH_STATE_KEY ] if state != expected_state : logging . warning ( f \"Unknown state token, expected: { expected_state !r} actual: { state !r} \" ) raise ValueError ( f \"Unknown state token\" ) data = { \"grant_type\" : \"authorization_code\" , \"client_id\" : self . _oauth_params . client_id , \"client_secret\" : self . _oauth_params . client_secret , \"code\" : code , \"redirect_uri\" : constants . FIXIE_OAUTH_REDIRECT_URL , } response = _send_authorize_request ( self . _oauth_params . token_uri , data ) logging . debug ( f \"OAuth auth request succeeded, lifetime= { response . expires_in } \" f \"refreshable= { response . refresh_token is not None } \" ) credentials = _OAuthCredentials ( response . access_token , _get_expiry ( response . expires_in ), response . refresh_token , ) self . _save_credentials ( credentials ) get_authorization_url () Returns a URL to launch the authorization flow. Source code in fixieai/agents/oauth.py 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 def get_authorization_url ( self ) -> str : \"\"\"Returns a URL to launch the authorization flow.\"\"\" auth_state = f \" { self . _agent_id } : { secrets . token_urlsafe () } \" data = { \"response_type\" : \"code\" , \"access_type\" : \"offline\" , \"client_id\" : self . _oauth_params . client_id , \"scope\" : \" \" . join ( self . _oauth_params . scopes ), \"state\" : auth_state , \"redirect_uri\" : constants . FIXIE_OAUTH_REDIRECT_URL , } url = self . _oauth_params . auth_uri + \"?\" + parse . urlencode ( data ) # Store auth_state in UserStorage for validation later. self . _storage [ self . OAUTH_STATE_KEY ] = auth_state return url user_token () Returns current user's OAuth credentials, or None if not authorized. Source code in fixieai/agents/oauth.py 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 def user_token ( self ) -> Optional [ str ]: \"\"\"Returns current user's OAuth credentials, or None if not authorized.\"\"\" try : creds_json = self . _storage [ self . OAUTH_TOKEN_KEY ] except KeyError : return None if not isinstance ( creds_json , str ): logging . warning ( f \"Value at user_storage[ { self . OAUTH_TOKEN_KEY !r} ] is \" f \"not an OAuthCredentials json: { creds_json !r} \" ) del self . _storage [ self . OAUTH_TOKEN_KEY ] return None try : creds = _OAuthCredentials . from_json ( creds_json ) except ( TypeError , LookupError , ValueError ): logging . warning ( f \"Value at user_storage[ { self . OAUTH_TOKEN_KEY !r} ] is \" f \"not a valid _OAuthCredentials json: { creds_json !r} \" ) del self . _storage [ self . OAUTH_TOKEN_KEY ] return None if creds . expired : logging . debug ( f \"Credentials expired at { creds . expiry } \" ) if not creds . refresh_token : logging . warning ( \"No refresh token available\" ) return None logging . debug ( \"Refreshing credentials...\" ) creds . refresh ( self . _oauth_params ) self . _save_credentials ( creds ) # Save refreshed token to UserStorage return creds . access_token OAuthParams dataclass Encapsulates OAuth parameters, including secret, auth uri, and the scope. Agents who want to use OAuth flow, should declare their secrets via this object. Source code in fixieai/agents/oauth.py 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 @dataclasses . dataclass class OAuthParams : \"\"\"Encapsulates OAuth parameters, including secret, auth uri, and the scope. Agents who want to use OAuth flow, should declare their secrets via this object. \"\"\" client_id : str client_secret : str auth_uri : str token_uri : str scopes : List [ str ] @classmethod def from_client_secrets_file ( cls , secrets_path : str , scopes : List [ str ] ) -> \"OAuthParams\" : \"\"\"Initializes OAuth from a secrets file, e.g., as obtained from the Google Cloud Console. Args: secrets_path: Path to a json file holding secret values. scopes: A list of scopes that access needs to be requested for. \"\"\" with open ( secrets_path , \"r\" ) as file : data = json . load ( file ) secrets = data [ \"web\" ] or data [ \"installed\" ] return cls ( secrets [ \"client_id\" ], secrets [ \"client_secret\" ], secrets [ \"auth_uri\" ], secrets [ \"token_uri\" ], scopes , ) from_client_secrets_file ( secrets_path , scopes ) classmethod Initializes OAuth from a secrets file, e.g., as obtained from the Google Cloud Console. Parameters: secrets_path ( str ) \u2013 Path to a json file holding secret values. scopes ( List [ str ] ) \u2013 A list of scopes that access needs to be requested for. Source code in fixieai/agents/oauth.py 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 @classmethod def from_client_secrets_file ( cls , secrets_path : str , scopes : List [ str ] ) -> \"OAuthParams\" : \"\"\"Initializes OAuth from a secrets file, e.g., as obtained from the Google Cloud Console. Args: secrets_path: Path to a json file holding secret values. scopes: A list of scopes that access needs to be requested for. \"\"\" with open ( secrets_path , \"r\" ) as file : data = json . load ( file ) secrets = data [ \"web\" ] or data [ \"installed\" ] return cls ( secrets [ \"client_id\" ], secrets [ \"client_secret\" ], secrets [ \"auth_uri\" ], secrets [ \"token_uri\" ], scopes , ) StandaloneAgent Bases: agent_base . AgentBase An agent that handles queries directly. To make a StandaloneAgent, pass a function with the following signature def handle(query: fixieai.Message) -> ReturnType: ... where ReturnType is one of str , fixieai.Message , or fixie.AgentResponse . Source code in fixieai/agents/standalone.py 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 class StandaloneAgent ( agent_base . AgentBase ): \"\"\"An agent that handles queries directly. To make a StandaloneAgent, pass a function with the following signature def handle(query: fixieai.Message) -> ReturnType: ... where ReturnType is one of `str`, `fixieai.Message`, or `fixie.AgentResponse`. \"\"\" def __init__ ( self , handle_message : Callable , sample_queries : Optional [ List [ str ]] = None , oauth_params : Optional [ oauth . OAuthParams ] = None , ): super () . __init__ ( oauth_params ) if isinstance ( handle_message , agent_func . AgentFunc ): self . _handle_message : agent_func . AgentFunc = handle_message else : self . _handle_message = agent_func . AgentQueryFunc . create ( handle_message , oauth_params , default_message_type = api . Message , allow_generator = True , ) self . _sample_queries = sample_queries def metadata ( self ) -> metadata . Metadata : return metadata . StandaloneAgentMetadata ( sample_queries = self . _sample_queries ) def validate ( self ): pass def api_router ( self ) -> fastapi . APIRouter : router = super () . api_router () router . add_api_route ( \"/\" , self . _serve_query , methods = [ \"POST\" ]) return router def _serve_query ( self , query : api . AgentQuery , credentials : fastapi . security . HTTPAuthorizationCredentials = fastapi . Depends ( fastapi . security . HTTPBearer () ), ) -> fastapi . responses . Response : \"\"\"Verifies the request is a valid request from Fixie, and dispatches it to the previously specified `handle_message` function. Depending on the return value of that function, either a single or a streaming response is returned. \"\"\" token_claims = super () . _check_credentials ( credentials ) output = self . _handle_message ( query , token_claims ) return fastapi . responses . StreamingResponse ( ( json . dumps ( dataclasses . asdict ( resp )) + \" \\n \" for resp in output ), media_type = \"application/json\" , ) UserStorage Bases: MutableMapping [ str , UserStorageType ] UserStorage provides a dict-like interface to a user-specific storage. Usage: from fixieai.agents import token storage = UserStorage(token.VerifiedTokenClaims(\"fake-agent\", False, \"fake-access-token\")) storage[\"key\"] = \"value\" storage[\"complex-key\"] = {\"key1\": {\"key2\": [12, False, None, b\"binary\"]}} assert len(storage) == 2 assert storage \"complex-key\" \"key2\" == b\"binary\" Source code in fixieai/agents/user_storage.py 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 class UserStorage ( MutableMapping [ str , UserStorageType ]): \"\"\"UserStorage provides a dict-like interface to a user-specific storage. Usage: >>> from fixieai.agents import token >>> storage = UserStorage(token.VerifiedTokenClaims(\"fake-agent\", False, \"fake-access-token\")) >>> storage[\"key\"] = \"value\" >>> storage[\"complex-key\"] = {\"key1\": {\"key2\": [12, False, None, b\"binary\"]}} >>> assert len(storage) == 2 >>> assert storage[\"complex-key\"][\"key1\"][\"key2\"][-1] == b\"binary\" \"\"\" def __init__ ( self , token_claims : token . VerifiedTokenClaims , userstorage_url : str = constants . FIXIE_USER_STORAGE_URL , ): if token_claims . is_anonymous : raise exceptions . AgentException ( response_message = \"I'm sorry, you must login to use this agent.\" , error_code = \"ERR_USERSTORAGE_REQUIRES_USER\" , error_message = \"This agent requires user storage, which is not available to anonymous users. Please login or create an account.\" , http_status_code = 400 , ) self . _agent_id = token_claims . agent_id self . _userstorage_url = userstorage_url self . _session = requests . Session () self . _session . headers . update ({ \"Authorization\" : f \"Bearer { token_claims . token } \" }) def __setitem__ ( self , key : str , value : UserStorageType ): url = f \" { self . _userstorage_url } / { self . _agent_id } / { key } \" response = self . _session . post ( url , json = { \"data\" : to_json ( value )}) response . raise_for_status () def __getitem__ ( self , key : str ) -> UserStorageType : url = f \" { self . _userstorage_url } / { self . _agent_id } / { key } \" try : response = self . _session . get ( url ) response . raise_for_status () return from_json ( response . json ()[ \"data\" ]) except requests . exceptions . HTTPError as e : raise KeyError ( f \"Key { key } not found\" ) from e def __contains__ ( self , key : object ) -> bool : url = f \" { self . _userstorage_url } / { self . _agent_id } / { key } \" try : response = self . _session . head ( url ) response . raise_for_status () return True except requests . exceptions . HTTPError as e : return False def __delitem__ ( self , key : str ): url = f \" { self . _userstorage_url } / { self . _agent_id } / { key } \" try : response = self . _session . delete ( url ) response . raise_for_status () except requests . exceptions . HTTPError as e : raise KeyError ( f \"Key { key } not found\" ) from e def _get_all_keys ( self ): url = f \" { self . _userstorage_url } / { self . _agent_id } \" response = self . _session . get ( url ) response . raise_for_status () return [ value [ \"key\" ] for value in response . json ()] def __iter__ ( self ): return iter ( self . _get_all_keys ()) def __len__ ( self ): return len ( self . _get_all_keys ()) from_json ( json_dump ) Deserializes a UserStorageType from a JSON string. Source code in fixieai/agents/user_storage.py 101 102 103 def from_json ( json_dump : str ) -> UserStorageType : \"\"\"Deserializes a UserStorageType from a JSON string.\"\"\" return from_json_type ( json . loads ( json_dump )) from_json_type ( obj ) Decodes a JsonType to UserStorageType. Source code in fixieai/agents/user_storage.py 118 119 120 121 122 123 124 125 126 127 def from_json_type ( obj : JsonType ) -> UserStorageType : \"\"\"Decodes a JsonType to UserStorageType.\"\"\" if _is_bytes_encoded_json_dict ( obj ): return base64 . b64decode ( obj [ \"data\" ]) # type: ignore elif isinstance ( obj , list ): return [ from_json_type ( item ) for item in obj ] elif isinstance ( obj , dict ): return { key : from_json_type ( value ) for key , value in obj . items ()} else : return obj to_json ( obj ) Serialize a UserStorageType to a JSON string. Source code in fixieai/agents/user_storage.py 96 97 98 def to_json ( obj : UserStorageType ) -> str : \"\"\"Serialize a UserStorageType to a JSON string.\"\"\" return json . dumps ( to_json_type ( obj )) to_json_type ( obj ) Encodes a UserStorageType to JsonType. Source code in fixieai/agents/user_storage.py 106 107 108 109 110 111 112 113 114 115 def to_json_type ( obj : UserStorageType ) -> JsonType : \"\"\"Encodes a UserStorageType to JsonType.\"\"\" if isinstance ( obj , bytes ): return { \"type\" : \"_bytes_ascii\" , \"data\" : base64 . b64encode ( obj ) . decode ( \"ASCII\" )} elif isinstance ( obj , list ): return [ to_json_type ( item ) for item in obj ] elif isinstance ( obj , dict ): return { key : to_json_type ( value ) for key , value in obj . items ()} else : return obj FewshotLinePattern Bases: enum . Enum Source code in fixieai/agents/utils.py 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 class FewshotLinePattern ( enum . Enum ): QUERY = re . compile ( r \"^Q:\" ) AGENT_SAYS = re . compile ( r \"^Agent\\[(?P<agent_id>\\w+)] says:\" ) FUNC_SAYS = re . compile ( r \"^Func\\[(?P<func_name>\\w+)] says:\" ) ASK_AGENT = re . compile ( r \"^Ask Agent\\[(?P<agent_id>\\w+)]:\" ) ASK_FUNC = re . compile ( r \"^Ask Func\\[(?P<func_name>\\w+)]:\" ) RESPONSE = re . compile ( r \"^A:\" ) NO_PATTERN : None = None @classmethod def match ( cls , line : str ) -> Optional [ re . Match [ str ]]: \"\"\"Returns a match from a FewshotLinePattern for a given line, or None if nothing matched.\"\"\" if \" \\n \" in line : raise ValueError ( \"Cannot get the pattern for a multi-line text. Patterns must be \" \"extracted one line at a time.\" ) matches = [ match for prompt_pattern in cls if prompt_pattern is not cls . NO_PATTERN and ( match := prompt_pattern . value . match ( line )) ] if len ( matches ) > 1 : raise RuntimeError ( f \"More than one pattern ( { list ( FewshotLinePattern ( match . re ) for match in matches ) } ) matched the line { line !r} .\" ) elif len ( matches ) == 0 : return None match = matches [ 0 ] if match . re is cls . QUERY . value : if match . end () == len ( line ): raise ValueError ( \"A 'Q:' line cannot end without a query.\" ) assert isinstance ( match , re . Match ) return match match ( line ) classmethod Returns a match from a FewshotLinePattern for a given line, or None if nothing matched. Source code in fixieai/agents/utils.py 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 @classmethod def match ( cls , line : str ) -> Optional [ re . Match [ str ]]: \"\"\"Returns a match from a FewshotLinePattern for a given line, or None if nothing matched.\"\"\" if \" \\n \" in line : raise ValueError ( \"Cannot get the pattern for a multi-line text. Patterns must be \" \"extracted one line at a time.\" ) matches = [ match for prompt_pattern in cls if prompt_pattern is not cls . NO_PATTERN and ( match := prompt_pattern . value . match ( line )) ] if len ( matches ) > 1 : raise RuntimeError ( f \"More than one pattern ( { list ( FewshotLinePattern ( match . re ) for match in matches ) } ) matched the line { line !r} .\" ) elif len ( matches ) == 0 : return None match = matches [ 0 ] if match . re is cls . QUERY . value : if match . end () == len ( line ): raise ValueError ( \"A 'Q:' line cannot end without a query.\" ) assert isinstance ( match , re . Match ) return match strip_prompt_lines ( agent ) Strips all prompt lines. Source code in fixieai/agents/utils.py 14 15 16 17 18 def strip_prompt_lines ( agent : code_shot . CodeShotAgent ): \"\"\"Strips all prompt lines.\"\"\" agent . base_prompt = _strip_all_lines ( agent . base_prompt ) for i , fewshot in enumerate ( agent . few_shots ): agent . few_shots [ i ] = _strip_all_lines ( fewshot ) validate_code_shot_agent ( agent ) A client-side validation of few_shots and agent. Source code in fixieai/agents/utils.py 21 22 23 24 25 26 27 def validate_code_shot_agent ( agent : code_shot . CodeShotAgent ): \"\"\"A client-side validation of few_shots and agent.\"\"\" _validate_base_prompt ( agent . base_prompt ) for fewshot in agent . few_shots : _validate_few_shot_prompt ( fewshot , agent . conversational , agent . is_valid_func_name )","title":"Python Agent API"},{"location":"python-agent-api/#fixie-agent-python-api-reference","text":"This module holds objects that represent the API interface by which Agents talk to Fixie ecosystem.","title":"Fixie Agent Python API Reference"},{"location":"python-agent-api/#fixieai.agents.api.AgentError","text":"An error that occurred in the process of generating a response. Source code in fixieai/agents/api.py 72 73 74 75 76 77 78 79 80 81 82 83 @pydantic_dataclasses . dataclass class AgentError : \"\"\"An error that occurred in the process of generating a response.\"\"\" # A code representing the error. code : str # A message describing the error that will be displayed to the user. message : str # Additional debugging context from the error. details : Optional [ Dict ]","title":"AgentError"},{"location":"python-agent-api/#fixieai.agents.api.AgentQuery","text":"A standalone query sent to a Fixie agent. Source code in fixieai/agents/api.py 58 59 60 61 62 63 64 65 66 67 68 69 @pydantic_dataclasses . dataclass class AgentQuery : \"\"\"A standalone query sent to a Fixie agent.\"\"\" # The contents of the query. message : Message # This is an access token associated with the user for whom this query was # created. Agents wishing to make queries to other agents, or to other # Fixie services, should carry this token in the query so that it # can be tied back to the original user. access_token : Optional [ str ] = None","title":"AgentQuery"},{"location":"python-agent-api/#fixieai.agents.api.AgentResponse","text":"A response message from an Agent. Source code in fixieai/agents/api.py 86 87 88 89 90 91 92 93 94 95 @pydantic_dataclasses . dataclass class AgentResponse : \"\"\"A response message from an Agent.\"\"\" # The text of the response message. message : Message # Error details, if an error occurred generating the response. Note that `message` should still be included, # but may indicate that an error occurred that prevented the agent from fully handling the request. error : Optional [ AgentError ] = None","title":"AgentResponse"},{"location":"python-agent-api/#fixieai.agents.api.Embed","text":"An Embed represents a binary object attached to a Message. Source code in fixieai/agents/api.py 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 @pydantic_dataclasses . dataclass class Embed : \"\"\"An Embed represents a binary object attached to a Message.\"\"\" # The MIME content type of the object, e.g., \"image/png\" or \"application/json\". content_type : str # A public URL where the object can be downloaded. This can be a data URI. uri : str @property def content ( self ) -> bytes : \"\"\"Retrieves the content for this Embed object.\"\"\" if self . uri . startswith ( \"data:\" ): return base64 . b64decode ( self . uri . split ( \",\" )[ 1 ]) return requests . get ( self . uri ) . content @content . setter def content ( self , content : bytes ): \"\"\"Sets the content of the Embed object as a data URI.\"\"\" self . uri = f \"data:base64, { base64 . b64encode ( content ) . decode ( 'utf-8' ) } \" @property def text ( self ) -> str : \"\"\"Retrieves the content of the Embed object as a string.\"\"\" return self . content . decode ( \"utf-8\" ) @text . setter def text ( self , text : str ): \"\"\"Sets the content of the Embed object as a string.\"\"\" self . content = text . encode ( \"utf-8\" )","title":"Embed"},{"location":"python-agent-api/#fixieai.agents.api.Embed.content","text":"Retrieves the content for this Embed object.","title":"content"},{"location":"python-agent-api/#fixieai.agents.api.Embed.text","text":"Retrieves the content of the Embed object as a string.","title":"text"},{"location":"python-agent-api/#fixieai.agents.api.Message","text":"A Message represents a single message sent to a Fixie agent. Source code in fixieai/agents/api.py 47 48 49 50 51 52 53 54 55 @pydantic_dataclasses . dataclass class Message : \"\"\"A Message represents a single message sent to a Fixie agent.\"\"\" # The text of the message. text : str # A mapping of embed keys to Embed objects. embeds : Dict [ str , Embed ] = dataclasses . field ( default_factory = dict )","title":"Message"},{"location":"python-agent-api/#fixieai.agents.code_shot.CodeShotAgent","text":"Bases: agent_base . AgentBase A CodeShot agent. To make a CodeShot agent, simply pass a BASE_PROMPT and FEW_SHOTS: BASE_PROMPT = \"A summary of what this agent does; how it does it; and its personality \" FEW_SHOTS = ''' Q: <Sample query that this agent supports> A: <Desired response for this query> Q: <Another sample query> A: <Desired response for this query> ''' agent = CodeShotAgent(BASE_PROMPT, FEW_SHOTS) You can have FEW_SHOTS as a single string of all your few-shots separated by 2 new lines, or as an explicit list of one few-shot per index. Your few-shots may reach out to other Agents in the fixie ecosystem by \"Ask Agent[agent_id]: \", or reach out to some python functions by \"Ask Func[func_name]: \". There are a series of default runtime Func s provided by the platform available for your agents to consume. For a full list of default runtime Func s, refer to: http://docs.fixie.ai/XXX You may also need to write your own python functions here to be consumed by your agent. To make a function accessible by an agent, you'd need to register it by @agent.register_func . Example: @agent.register_func def func_name ( query : fixieai . Message ) -> ReturnType : ... , where ReturnType is one of `str` , `fixieai.Message` , or `fixie.AgentResponse` . Note that in the above, we are using the decorator @agent.register_func to register this function with the agent instance we just created. To check out the default Func s that are provided in Fixie, see: http://docs.fixie.ai/XXX Source code in fixieai/agents/code_shot.py 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 class CodeShotAgent ( agent_base . AgentBase ): \"\"\"A CodeShot agent. To make a CodeShot agent, simply pass a BASE_PROMPT and FEW_SHOTS: BASE_PROMPT = \"A summary of what this agent does; how it does it; and its personality\" FEW_SHOTS = ''' Q: <Sample query that this agent supports> A: <Desired response for this query> Q: <Another sample query> A: <Desired response for this query> ''' agent = CodeShotAgent(BASE_PROMPT, FEW_SHOTS) You can have FEW_SHOTS as a single string of all your few-shots separated by 2 new lines, or as an explicit list of one few-shot per index. Your few-shots may reach out to other Agents in the fixie ecosystem by \"Ask Agent[agent_id]: <query to pass>\", or reach out to some python functions by \"Ask Func[func_name]: <query to pass>\". There are a series of default runtime `Func`s provided by the platform available for your agents to consume. For a full list of default runtime `Func`s, refer to: http://docs.fixie.ai/XXX You may also need to write your own python functions here to be consumed by your agent. To make a function accessible by an agent, you'd need to register it by `@agent.register_func`. Example: @agent.register_func def func_name(query: fixieai.Message) -> ReturnType: ... , where ReturnType is one of `str`, `fixieai.Message`, or `fixie.AgentResponse`. Note that in the above, we are using the decorator `@agent.register_func` to register this function with the agent instance we just created. To check out the default `Func`s that are provided in Fixie, see: http://docs.fixie.ai/XXX \"\"\" def __init__ ( self , base_prompt : str , few_shots : Union [ str , List [ str ]], corpora : Optional [ List [ corpora . UrlDocumentCorpus ]] = None , conversational : bool = False , oauth_params : Optional [ oauth . OAuthParams ] = None , llm_settings : Optional [ llm_settings . LlmSettings ] = None , ): super () . __init__ ( oauth_params ) if isinstance ( few_shots , str ): few_shots = _split_few_shots ( few_shots ) self . base_prompt = base_prompt self . few_shots = few_shots self . url_corpora = corpora self . conversational = conversational self . llm_settings = llm_settings utils . strip_prompt_lines ( self ) @property def corpora ( self ): url_corpora = self . url_corpora or [] custom_corpora = [ corpora . CustomCorpus ( func_name = f ) for f in self . _corpus_funcs . keys () ] return url_corpora + custom_corpora if url_corpora or custom_corpora else None def metadata ( self ) -> metadata . Metadata : return metadata . CodeShotAgentMetadata ( self . base_prompt , self . few_shots , self . corpora , self . conversational , self . llm_settings , ) def validate ( self ): utils . validate_code_shot_agent ( self )","title":"CodeShotAgent"},{"location":"python-agent-api/#fixieai.agents.corpora.CorpusDocument","text":"Some meaningful item of data from a corpus. This could be an HTML page, a PDF, or a raw string of text (among others). Fixie will handle parsing and chunking this document so that appropriately sized chunks can be included in LLM requests. Note: If custom parsing is desired, agents are free to implement their own parsing to return documents with text/plain mime_types instead of whatever they fetch natively. Fixie will not alter text/plain documents prior to chunking. Source code in fixieai/agents/corpora.py 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 @pydantic_dataclasses . dataclass class CorpusDocument : \"\"\"Some meaningful item of data from a corpus. This could be an HTML page, a PDF, or a raw string of text (among others). Fixie will handle parsing and chunking this document so that appropriately sized chunks can be included in LLM requests. Note: If custom parsing is desired, agents are free to implement their own parsing to return documents with text/plain mime_types instead of whatever they fetch natively. Fixie will not alter text/plain documents prior to chunking.\"\"\" source_name : str content : bytes = dataclasses . field ( metadata = dataclasses_json . config ( encoder = lambda c : base64 . b64encode ( c ) . decode (), decoder = lambda c : base64 . b64decode ( c . encode ()), ) ) encoding : str = \"UTF-8\" mime_type : str = \"text/plain\" @property def text ( self ) -> str : return self . content . decode ( self . encoding )","title":"CorpusDocument"},{"location":"python-agent-api/#fixieai.agents.corpora.CorpusPage","text":"A page of CorpusDocuments. In addition to the documents themselves, a page may include a continuation token for fetching the next page (in the same partition). Omitting a token implies that this is the last page. Source code in fixieai/agents/corpora.py 127 128 129 130 131 132 133 134 @pydantic_dataclasses . dataclass class CorpusPage : \"\"\"A page of CorpusDocuments. In addition to the documents themselves, a page may include a continuation token for fetching the next page (in the same partition). Omitting a token implies that this is the last page.\"\"\" documents : List [ CorpusDocument ] next_page_token : Optional [ str ] = None","title":"CorpusPage"},{"location":"python-agent-api/#fixieai.agents.corpora.CorpusPartition","text":"An identifier for a subset of a corpus, along with an optional token to use when loading its first page. Each partition will only be loaded once during a single crawl. If multiple responses include the same partition, the token of the first received response will be used. Source code in fixieai/agents/corpora.py 89 90 91 92 93 94 95 96 97 @pydantic_dataclasses . dataclass class CorpusPartition : \"\"\"An identifier for a subset of a corpus, along with an optional token to use when loading its first page. Each partition will only be loaded once during a single crawl. If multiple responses include the same partition, the token of the first received response will be used.\"\"\" partition : str first_page_token : Optional [ str ] = None","title":"CorpusPartition"},{"location":"python-agent-api/#fixieai.agents.corpora.CorpusRequest","text":"Bases: dataclasses_json . DataClassJsonMixin A request for some piece of the agent's corpus. In addition to returning documents, each response may expand the corpus space in one or both of two dimensions: new partitions and next pages. Partitions are non-overlapping subsets of a corpus which may be loaded in parallel by Fixie. A response's new partitions will be ignored if previously included in another response. When a response includes a page of documents, that page may indicate that another page is available in the same partition. Pages are always loaded serially in order. The partition is completed when a response has a page with no next_page_token. Agents will always receive a first request with the default (unnamed) partition and no page_token. Subsequent requests depend on prior responses and will always include at least one of those fields. Examples: Simple handful of documents: When receiving the initial request , the agent responds with a page of documents . This could include a next_page_token for more documents in the single default partition if needed . Web crawl: Each URL corresponds to a partition and the agent never returns tokens . The initial response only includes partitions , one for each root URL to crawl . Each subsequent request includes the partition ( the URL ) and the corresponding response contains a page with a single document - the resource at that URL . If the document links to other resources that should be included in the corpus , the response also contains those URLs as new partitions . The process repeats for all partitions until there are no known incomplete partitions or until crawl limits are reached . Database: Consider a database with a parent table keyed by parent_id and an interleaved child table keyed by ( parent_id , child_id ) whose rows correspond to corpus documents . This agent will use tokens that encode a read timestamp ( for consistency ) and an offset to be used in combination with a static page size . Upon receiving the initial CorpusRequest , the agent chooses a commit timestamp to use for all reads and returns a partition for each parent_id along with a first_page_token indicating the chosen read timestamp and an offset of 0 . For each partition , the agent then receives requests with the partition ( a parent_id ) and a page token ( the read timestamp and offest ) . It responds with documents corresponding to the next page size child rows within the given parent . If more children exist , the response includes a next_page_token with the same read timestamp and an incremented offset . This repeats until there are no more children , at which point the response has no next_page_token and the partition is complete . Note : Including multiple parent_ids in each partition would also work and would be an effective way to limit parallelism if desired . Attributes: partition ( Optional [ str ] ) \u2013 The partition of the corpus that should be read. This will be empty for the initial request, indicating the default partition. For subsequent requests, it will either be the name of a partition returned by a previous request or empty if the default partition contains multiple pages for this agent. page_token ( Optional [ str ] ) \u2013 A token for paginating results within a corpus partition. If present, this will be echoed from a previous response. Source code in fixieai/agents/corpora.py 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 @pydantic_dataclasses . dataclass class CorpusRequest ( dataclasses_json . DataClassJsonMixin ): \"\"\"A request for some piece of the agent's corpus. In addition to returning documents, each response may expand the corpus space in one or both of two dimensions: new partitions and next pages. Partitions are non-overlapping subsets of a corpus which may be loaded in parallel by Fixie. A response's new partitions will be ignored if previously included in another response. When a response includes a page of documents, that page may indicate that another page is available in the same partition. Pages are always loaded serially in order. The partition is completed when a response has a page with no next_page_token. Agents will always receive a first request with the default (unnamed) partition and no page_token. Subsequent requests depend on prior responses and will always include at least one of those fields. Examples: Simple handful of documents: When receiving the initial request, the agent responds with a page of documents. This could include a next_page_token for more documents in the single default partition if needed. Web crawl: Each URL corresponds to a partition and the agent never returns tokens. The initial response only includes partitions, one for each root URL to crawl. Each subsequent request includes the partition (the URL) and the corresponding response contains a page with a single document - the resource at that URL. If the document links to other resources that should be included in the corpus, the response also contains those URLs as new partitions. The process repeats for all partitions until there are no known incomplete partitions or until crawl limits are reached. Database: Consider a database with a parent table keyed by parent_id and an interleaved child table keyed by (parent_id, child_id) whose rows correspond to corpus documents. This agent will use tokens that encode a read timestamp (for consistency) and an offset to be used in combination with a static page size. Upon receiving the initial CorpusRequest, the agent chooses a commit timestamp to use for all reads and returns a partition for each parent_id along with a first_page_token indicating the chosen read timestamp and an offset of 0. For each partition, the agent then receives requests with the partition (a parent_id) and a page token (the read timestamp and offest). It responds with documents corresponding to the next page size child rows within the given parent. If more children exist, the response includes a next_page_token with the same read timestamp and an incremented offset. This repeats until there are no more children, at which point the response has no next_page_token and the partition is complete. Note: Including multiple parent_ids in each partition would also work and would be an effective way to limit parallelism if desired. Attributes: partition: The partition of the corpus that should be read. This will be empty for the initial request, indicating the default partition. For subsequent requests, it will either be the name of a partition returned by a previous request or empty if the default partition contains multiple pages for this agent. page_token: A token for paginating results within a corpus partition. If present, this will be echoed from a previous response. \"\"\" partition : Optional [ str ] = None page_token : Optional [ str ] = None","title":"CorpusRequest"},{"location":"python-agent-api/#fixieai.agents.corpora.CorpusResponse","text":"Bases: dataclasses_json . DataClassJsonMixin A response to a CorpusRequest. See CorpusRequest for details. Source code in fixieai/agents/corpora.py 137 138 139 140 141 142 @pydantic_dataclasses . dataclass class CorpusResponse ( dataclasses_json . DataClassJsonMixin ): \"\"\"A response to a CorpusRequest. See CorpusRequest for details.\"\"\" partitions : Optional [ List [ CorpusPartition ]] = None page : Optional [ CorpusPage ] = None","title":"CorpusResponse"},{"location":"python-agent-api/#fixieai.agents.corpora.CustomCorpus","text":"A custom corpus for a Fixie CodeShot Agent. This uses a registered corpus func to load documents from an arbitrary source. Source code in fixieai/agents/corpora.py 145 146 147 148 149 150 @pydantic_dataclasses . dataclass class CustomCorpus : \"\"\"A custom corpus for a Fixie CodeShot Agent. This uses a registered corpus func to load documents from an arbitrary source.\"\"\" func_name : str","title":"CustomCorpus"},{"location":"python-agent-api/#fixieai.agents.corpora.DocumentLoader","text":"Deprecated. This doesn't do anything. Source code in fixieai/agents/corpora.py 153 154 155 156 157 158 @deprecated ( reason = \"Use register_corpus_func for custom document loading.\" ) @pydantic_dataclasses . dataclass class DocumentLoader : \"\"\"Deprecated. This doesn't do anything.\"\"\" name : str","title":"DocumentLoader"},{"location":"python-agent-api/#fixieai.agents.corpora.UrlDocumentCorpus","text":"URL Document corpus for a Fixie CodeShot Agent. Source code in fixieai/agents/corpora.py 161 162 163 164 165 166 167 168 169 170 171 172 173 174 @pydantic_dataclasses . dataclass class UrlDocumentCorpus : \"\"\"URL Document corpus for a Fixie CodeShot Agent.\"\"\" urls : List [ str ] \"\"\"URLs to load documents from. A trailing wildcard (e.g., https://example.com/*), can be used to load all documents from a site.\"\"\" exclude_patterns : Optional [ List [ str ]] = None \"\"\"A list of wildcard patterns to exclude from crawled URLs (e.g., */no_crawl/*).\"\"\" auth_token_func : Optional [ str ] = None loader : Optional [ DocumentLoader ] = None # Deprecated.","title":"UrlDocumentCorpus"},{"location":"python-agent-api/#fixieai.agents.corpora.UrlDocumentCorpus.exclude_patterns","text":"A list of wildcard patterns to exclude from crawled URLs (e.g., /no_crawl/ ).","title":"exclude_patterns"},{"location":"python-agent-api/#fixieai.agents.corpora.UrlDocumentCorpus.urls","text":"URLs to load documents from. A trailing wildcard (e.g., https://example.com/*), can be used to load all documents from a site.","title":"urls"},{"location":"python-agent-api/#fixieai.agents.oauth.OAuthHandler","text":"OAuthHandler that wraps around a (OAuthParams, query) to authenticate. This client object provides 3 main method credentials: Returns current user's OAuth access token, or None if they are not authenticated. get_authorization_url: Returns a url that the users can click to authenticate themselves. authorize: Exchanges a received access code (from auth redirect callback) for an access token. If successful, user's storage is updated. Source code in fixieai/agents/oauth.py 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 class OAuthHandler : \"\"\" OAuthHandler that wraps around a (OAuthParams, query) to authenticate. This client object provides 3 main method: * credentials: Returns current user's OAuth access token, or None if they are not authenticated. * get_authorization_url: Returns a url that the users can click to authenticate themselves. * authorize: Exchanges a received access code (from auth redirect callback) for an access token. If successful, user's storage is updated. \"\"\" # OAuth keys reserved in UserStorage OAUTH_STATE_KEY = \"_oauth_state\" OAUTH_TOKEN_KEY = \"_oauth_token\" def __init__ ( self , oauth_params : OAuthParams , token_claims : token . VerifiedTokenClaims , ): self . _storage = user_storage . UserStorage ( token_claims ) self . _oauth_params = oauth_params self . _agent_id = token_claims . agent_id def get_authorization_url ( self ) -> str : \"\"\"Returns a URL to launch the authorization flow.\"\"\" auth_state = f \" { self . _agent_id } : { secrets . token_urlsafe () } \" data = { \"response_type\" : \"code\" , \"access_type\" : \"offline\" , \"client_id\" : self . _oauth_params . client_id , \"scope\" : \" \" . join ( self . _oauth_params . scopes ), \"state\" : auth_state , \"redirect_uri\" : constants . FIXIE_OAUTH_REDIRECT_URL , } url = self . _oauth_params . auth_uri + \"?\" + parse . urlencode ( data ) # Store auth_state in UserStorage for validation later. self . _storage [ self . OAUTH_STATE_KEY ] = auth_state return url def user_token ( self ) -> Optional [ str ]: \"\"\"Returns current user's OAuth credentials, or None if not authorized.\"\"\" try : creds_json = self . _storage [ self . OAUTH_TOKEN_KEY ] except KeyError : return None if not isinstance ( creds_json , str ): logging . warning ( f \"Value at user_storage[ { self . OAUTH_TOKEN_KEY !r} ] is \" f \"not an OAuthCredentials json: { creds_json !r} \" ) del self . _storage [ self . OAUTH_TOKEN_KEY ] return None try : creds = _OAuthCredentials . from_json ( creds_json ) except ( TypeError , LookupError , ValueError ): logging . warning ( f \"Value at user_storage[ { self . OAUTH_TOKEN_KEY !r} ] is \" f \"not a valid _OAuthCredentials json: { creds_json !r} \" ) del self . _storage [ self . OAUTH_TOKEN_KEY ] return None if creds . expired : logging . debug ( f \"Credentials expired at { creds . expiry } \" ) if not creds . refresh_token : logging . warning ( \"No refresh token available\" ) return None logging . debug ( \"Refreshing credentials...\" ) creds . refresh ( self . _oauth_params ) self . _save_credentials ( creds ) # Save refreshed token to UserStorage return creds . access_token def authorize ( self , state : str , code : str ): \"\"\"Authorize the received access `code` against the client secret. If successful, the credentials will be saved in user storage. \"\"\" expected_state = self . _storage [ self . OAUTH_STATE_KEY ] if state != expected_state : logging . warning ( f \"Unknown state token, expected: { expected_state !r} actual: { state !r} \" ) raise ValueError ( f \"Unknown state token\" ) data = { \"grant_type\" : \"authorization_code\" , \"client_id\" : self . _oauth_params . client_id , \"client_secret\" : self . _oauth_params . client_secret , \"code\" : code , \"redirect_uri\" : constants . FIXIE_OAUTH_REDIRECT_URL , } response = _send_authorize_request ( self . _oauth_params . token_uri , data ) logging . debug ( f \"OAuth auth request succeeded, lifetime= { response . expires_in } \" f \"refreshable= { response . refresh_token is not None } \" ) credentials = _OAuthCredentials ( response . access_token , _get_expiry ( response . expires_in ), response . refresh_token , ) self . _save_credentials ( credentials ) def _save_credentials ( self , credentials : \"_OAuthCredentials\" ): self . _storage [ self . OAUTH_TOKEN_KEY ] = credentials . to_json ()","title":"OAuthHandler"},{"location":"python-agent-api/#fixieai.agents.oauth.OAuthHandler.authorize","text":"Authorize the received access code against the client secret. If successful, the credentials will be saved in user storage. Source code in fixieai/agents/oauth.py 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 def authorize ( self , state : str , code : str ): \"\"\"Authorize the received access `code` against the client secret. If successful, the credentials will be saved in user storage. \"\"\" expected_state = self . _storage [ self . OAUTH_STATE_KEY ] if state != expected_state : logging . warning ( f \"Unknown state token, expected: { expected_state !r} actual: { state !r} \" ) raise ValueError ( f \"Unknown state token\" ) data = { \"grant_type\" : \"authorization_code\" , \"client_id\" : self . _oauth_params . client_id , \"client_secret\" : self . _oauth_params . client_secret , \"code\" : code , \"redirect_uri\" : constants . FIXIE_OAUTH_REDIRECT_URL , } response = _send_authorize_request ( self . _oauth_params . token_uri , data ) logging . debug ( f \"OAuth auth request succeeded, lifetime= { response . expires_in } \" f \"refreshable= { response . refresh_token is not None } \" ) credentials = _OAuthCredentials ( response . access_token , _get_expiry ( response . expires_in ), response . refresh_token , ) self . _save_credentials ( credentials )","title":"authorize()"},{"location":"python-agent-api/#fixieai.agents.oauth.OAuthHandler.get_authorization_url","text":"Returns a URL to launch the authorization flow. Source code in fixieai/agents/oauth.py 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 def get_authorization_url ( self ) -> str : \"\"\"Returns a URL to launch the authorization flow.\"\"\" auth_state = f \" { self . _agent_id } : { secrets . token_urlsafe () } \" data = { \"response_type\" : \"code\" , \"access_type\" : \"offline\" , \"client_id\" : self . _oauth_params . client_id , \"scope\" : \" \" . join ( self . _oauth_params . scopes ), \"state\" : auth_state , \"redirect_uri\" : constants . FIXIE_OAUTH_REDIRECT_URL , } url = self . _oauth_params . auth_uri + \"?\" + parse . urlencode ( data ) # Store auth_state in UserStorage for validation later. self . _storage [ self . OAUTH_STATE_KEY ] = auth_state return url","title":"get_authorization_url()"},{"location":"python-agent-api/#fixieai.agents.oauth.OAuthHandler.user_token","text":"Returns current user's OAuth credentials, or None if not authorized. Source code in fixieai/agents/oauth.py 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 def user_token ( self ) -> Optional [ str ]: \"\"\"Returns current user's OAuth credentials, or None if not authorized.\"\"\" try : creds_json = self . _storage [ self . OAUTH_TOKEN_KEY ] except KeyError : return None if not isinstance ( creds_json , str ): logging . warning ( f \"Value at user_storage[ { self . OAUTH_TOKEN_KEY !r} ] is \" f \"not an OAuthCredentials json: { creds_json !r} \" ) del self . _storage [ self . OAUTH_TOKEN_KEY ] return None try : creds = _OAuthCredentials . from_json ( creds_json ) except ( TypeError , LookupError , ValueError ): logging . warning ( f \"Value at user_storage[ { self . OAUTH_TOKEN_KEY !r} ] is \" f \"not a valid _OAuthCredentials json: { creds_json !r} \" ) del self . _storage [ self . OAUTH_TOKEN_KEY ] return None if creds . expired : logging . debug ( f \"Credentials expired at { creds . expiry } \" ) if not creds . refresh_token : logging . warning ( \"No refresh token available\" ) return None logging . debug ( \"Refreshing credentials...\" ) creds . refresh ( self . _oauth_params ) self . _save_credentials ( creds ) # Save refreshed token to UserStorage return creds . access_token","title":"user_token()"},{"location":"python-agent-api/#fixieai.agents.oauth.OAuthParams","text":"Encapsulates OAuth parameters, including secret, auth uri, and the scope. Agents who want to use OAuth flow, should declare their secrets via this object. Source code in fixieai/agents/oauth.py 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 @dataclasses . dataclass class OAuthParams : \"\"\"Encapsulates OAuth parameters, including secret, auth uri, and the scope. Agents who want to use OAuth flow, should declare their secrets via this object. \"\"\" client_id : str client_secret : str auth_uri : str token_uri : str scopes : List [ str ] @classmethod def from_client_secrets_file ( cls , secrets_path : str , scopes : List [ str ] ) -> \"OAuthParams\" : \"\"\"Initializes OAuth from a secrets file, e.g., as obtained from the Google Cloud Console. Args: secrets_path: Path to a json file holding secret values. scopes: A list of scopes that access needs to be requested for. \"\"\" with open ( secrets_path , \"r\" ) as file : data = json . load ( file ) secrets = data [ \"web\" ] or data [ \"installed\" ] return cls ( secrets [ \"client_id\" ], secrets [ \"client_secret\" ], secrets [ \"auth_uri\" ], secrets [ \"token_uri\" ], scopes , )","title":"OAuthParams"},{"location":"python-agent-api/#fixieai.agents.oauth.OAuthParams.from_client_secrets_file","text":"Initializes OAuth from a secrets file, e.g., as obtained from the Google Cloud Console. Parameters: secrets_path ( str ) \u2013 Path to a json file holding secret values. scopes ( List [ str ] ) \u2013 A list of scopes that access needs to be requested for. Source code in fixieai/agents/oauth.py 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 @classmethod def from_client_secrets_file ( cls , secrets_path : str , scopes : List [ str ] ) -> \"OAuthParams\" : \"\"\"Initializes OAuth from a secrets file, e.g., as obtained from the Google Cloud Console. Args: secrets_path: Path to a json file holding secret values. scopes: A list of scopes that access needs to be requested for. \"\"\" with open ( secrets_path , \"r\" ) as file : data = json . load ( file ) secrets = data [ \"web\" ] or data [ \"installed\" ] return cls ( secrets [ \"client_id\" ], secrets [ \"client_secret\" ], secrets [ \"auth_uri\" ], secrets [ \"token_uri\" ], scopes , )","title":"from_client_secrets_file()"},{"location":"python-agent-api/#fixieai.agents.standalone.StandaloneAgent","text":"Bases: agent_base . AgentBase An agent that handles queries directly. To make a StandaloneAgent, pass a function with the following signature def handle(query: fixieai.Message) -> ReturnType: ... where ReturnType is one of str , fixieai.Message , or fixie.AgentResponse . Source code in fixieai/agents/standalone.py 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 class StandaloneAgent ( agent_base . AgentBase ): \"\"\"An agent that handles queries directly. To make a StandaloneAgent, pass a function with the following signature def handle(query: fixieai.Message) -> ReturnType: ... where ReturnType is one of `str`, `fixieai.Message`, or `fixie.AgentResponse`. \"\"\" def __init__ ( self , handle_message : Callable , sample_queries : Optional [ List [ str ]] = None , oauth_params : Optional [ oauth . OAuthParams ] = None , ): super () . __init__ ( oauth_params ) if isinstance ( handle_message , agent_func . AgentFunc ): self . _handle_message : agent_func . AgentFunc = handle_message else : self . _handle_message = agent_func . AgentQueryFunc . create ( handle_message , oauth_params , default_message_type = api . Message , allow_generator = True , ) self . _sample_queries = sample_queries def metadata ( self ) -> metadata . Metadata : return metadata . StandaloneAgentMetadata ( sample_queries = self . _sample_queries ) def validate ( self ): pass def api_router ( self ) -> fastapi . APIRouter : router = super () . api_router () router . add_api_route ( \"/\" , self . _serve_query , methods = [ \"POST\" ]) return router def _serve_query ( self , query : api . AgentQuery , credentials : fastapi . security . HTTPAuthorizationCredentials = fastapi . Depends ( fastapi . security . HTTPBearer () ), ) -> fastapi . responses . Response : \"\"\"Verifies the request is a valid request from Fixie, and dispatches it to the previously specified `handle_message` function. Depending on the return value of that function, either a single or a streaming response is returned. \"\"\" token_claims = super () . _check_credentials ( credentials ) output = self . _handle_message ( query , token_claims ) return fastapi . responses . StreamingResponse ( ( json . dumps ( dataclasses . asdict ( resp )) + \" \\n \" for resp in output ), media_type = \"application/json\" , )","title":"StandaloneAgent"},{"location":"python-agent-api/#fixieai.agents.user_storage.UserStorage","text":"Bases: MutableMapping [ str , UserStorageType ] UserStorage provides a dict-like interface to a user-specific storage. Usage: from fixieai.agents import token storage = UserStorage(token.VerifiedTokenClaims(\"fake-agent\", False, \"fake-access-token\")) storage[\"key\"] = \"value\" storage[\"complex-key\"] = {\"key1\": {\"key2\": [12, False, None, b\"binary\"]}} assert len(storage) == 2 assert storage \"complex-key\" \"key2\" == b\"binary\" Source code in fixieai/agents/user_storage.py 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 class UserStorage ( MutableMapping [ str , UserStorageType ]): \"\"\"UserStorage provides a dict-like interface to a user-specific storage. Usage: >>> from fixieai.agents import token >>> storage = UserStorage(token.VerifiedTokenClaims(\"fake-agent\", False, \"fake-access-token\")) >>> storage[\"key\"] = \"value\" >>> storage[\"complex-key\"] = {\"key1\": {\"key2\": [12, False, None, b\"binary\"]}} >>> assert len(storage) == 2 >>> assert storage[\"complex-key\"][\"key1\"][\"key2\"][-1] == b\"binary\" \"\"\" def __init__ ( self , token_claims : token . VerifiedTokenClaims , userstorage_url : str = constants . FIXIE_USER_STORAGE_URL , ): if token_claims . is_anonymous : raise exceptions . AgentException ( response_message = \"I'm sorry, you must login to use this agent.\" , error_code = \"ERR_USERSTORAGE_REQUIRES_USER\" , error_message = \"This agent requires user storage, which is not available to anonymous users. Please login or create an account.\" , http_status_code = 400 , ) self . _agent_id = token_claims . agent_id self . _userstorage_url = userstorage_url self . _session = requests . Session () self . _session . headers . update ({ \"Authorization\" : f \"Bearer { token_claims . token } \" }) def __setitem__ ( self , key : str , value : UserStorageType ): url = f \" { self . _userstorage_url } / { self . _agent_id } / { key } \" response = self . _session . post ( url , json = { \"data\" : to_json ( value )}) response . raise_for_status () def __getitem__ ( self , key : str ) -> UserStorageType : url = f \" { self . _userstorage_url } / { self . _agent_id } / { key } \" try : response = self . _session . get ( url ) response . raise_for_status () return from_json ( response . json ()[ \"data\" ]) except requests . exceptions . HTTPError as e : raise KeyError ( f \"Key { key } not found\" ) from e def __contains__ ( self , key : object ) -> bool : url = f \" { self . _userstorage_url } / { self . _agent_id } / { key } \" try : response = self . _session . head ( url ) response . raise_for_status () return True except requests . exceptions . HTTPError as e : return False def __delitem__ ( self , key : str ): url = f \" { self . _userstorage_url } / { self . _agent_id } / { key } \" try : response = self . _session . delete ( url ) response . raise_for_status () except requests . exceptions . HTTPError as e : raise KeyError ( f \"Key { key } not found\" ) from e def _get_all_keys ( self ): url = f \" { self . _userstorage_url } / { self . _agent_id } \" response = self . _session . get ( url ) response . raise_for_status () return [ value [ \"key\" ] for value in response . json ()] def __iter__ ( self ): return iter ( self . _get_all_keys ()) def __len__ ( self ): return len ( self . _get_all_keys ())","title":"UserStorage"},{"location":"python-agent-api/#fixieai.agents.user_storage.from_json","text":"Deserializes a UserStorageType from a JSON string. Source code in fixieai/agents/user_storage.py 101 102 103 def from_json ( json_dump : str ) -> UserStorageType : \"\"\"Deserializes a UserStorageType from a JSON string.\"\"\" return from_json_type ( json . loads ( json_dump ))","title":"from_json()"},{"location":"python-agent-api/#fixieai.agents.user_storage.from_json_type","text":"Decodes a JsonType to UserStorageType. Source code in fixieai/agents/user_storage.py 118 119 120 121 122 123 124 125 126 127 def from_json_type ( obj : JsonType ) -> UserStorageType : \"\"\"Decodes a JsonType to UserStorageType.\"\"\" if _is_bytes_encoded_json_dict ( obj ): return base64 . b64decode ( obj [ \"data\" ]) # type: ignore elif isinstance ( obj , list ): return [ from_json_type ( item ) for item in obj ] elif isinstance ( obj , dict ): return { key : from_json_type ( value ) for key , value in obj . items ()} else : return obj","title":"from_json_type()"},{"location":"python-agent-api/#fixieai.agents.user_storage.to_json","text":"Serialize a UserStorageType to a JSON string. Source code in fixieai/agents/user_storage.py 96 97 98 def to_json ( obj : UserStorageType ) -> str : \"\"\"Serialize a UserStorageType to a JSON string.\"\"\" return json . dumps ( to_json_type ( obj ))","title":"to_json()"},{"location":"python-agent-api/#fixieai.agents.user_storage.to_json_type","text":"Encodes a UserStorageType to JsonType. Source code in fixieai/agents/user_storage.py 106 107 108 109 110 111 112 113 114 115 def to_json_type ( obj : UserStorageType ) -> JsonType : \"\"\"Encodes a UserStorageType to JsonType.\"\"\" if isinstance ( obj , bytes ): return { \"type\" : \"_bytes_ascii\" , \"data\" : base64 . b64encode ( obj ) . decode ( \"ASCII\" )} elif isinstance ( obj , list ): return [ to_json_type ( item ) for item in obj ] elif isinstance ( obj , dict ): return { key : to_json_type ( value ) for key , value in obj . items ()} else : return obj","title":"to_json_type()"},{"location":"python-agent-api/#fixieai.agents.utils.FewshotLinePattern","text":"Bases: enum . Enum Source code in fixieai/agents/utils.py 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 class FewshotLinePattern ( enum . Enum ): QUERY = re . compile ( r \"^Q:\" ) AGENT_SAYS = re . compile ( r \"^Agent\\[(?P<agent_id>\\w+)] says:\" ) FUNC_SAYS = re . compile ( r \"^Func\\[(?P<func_name>\\w+)] says:\" ) ASK_AGENT = re . compile ( r \"^Ask Agent\\[(?P<agent_id>\\w+)]:\" ) ASK_FUNC = re . compile ( r \"^Ask Func\\[(?P<func_name>\\w+)]:\" ) RESPONSE = re . compile ( r \"^A:\" ) NO_PATTERN : None = None @classmethod def match ( cls , line : str ) -> Optional [ re . Match [ str ]]: \"\"\"Returns a match from a FewshotLinePattern for a given line, or None if nothing matched.\"\"\" if \" \\n \" in line : raise ValueError ( \"Cannot get the pattern for a multi-line text. Patterns must be \" \"extracted one line at a time.\" ) matches = [ match for prompt_pattern in cls if prompt_pattern is not cls . NO_PATTERN and ( match := prompt_pattern . value . match ( line )) ] if len ( matches ) > 1 : raise RuntimeError ( f \"More than one pattern ( { list ( FewshotLinePattern ( match . re ) for match in matches ) } ) matched the line { line !r} .\" ) elif len ( matches ) == 0 : return None match = matches [ 0 ] if match . re is cls . QUERY . value : if match . end () == len ( line ): raise ValueError ( \"A 'Q:' line cannot end without a query.\" ) assert isinstance ( match , re . Match ) return match","title":"FewshotLinePattern"},{"location":"python-agent-api/#fixieai.agents.utils.FewshotLinePattern.match","text":"Returns a match from a FewshotLinePattern for a given line, or None if nothing matched. Source code in fixieai/agents/utils.py 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 @classmethod def match ( cls , line : str ) -> Optional [ re . Match [ str ]]: \"\"\"Returns a match from a FewshotLinePattern for a given line, or None if nothing matched.\"\"\" if \" \\n \" in line : raise ValueError ( \"Cannot get the pattern for a multi-line text. Patterns must be \" \"extracted one line at a time.\" ) matches = [ match for prompt_pattern in cls if prompt_pattern is not cls . NO_PATTERN and ( match := prompt_pattern . value . match ( line )) ] if len ( matches ) > 1 : raise RuntimeError ( f \"More than one pattern ( { list ( FewshotLinePattern ( match . re ) for match in matches ) } ) matched the line { line !r} .\" ) elif len ( matches ) == 0 : return None match = matches [ 0 ] if match . re is cls . QUERY . value : if match . end () == len ( line ): raise ValueError ( \"A 'Q:' line cannot end without a query.\" ) assert isinstance ( match , re . Match ) return match","title":"match()"},{"location":"python-agent-api/#fixieai.agents.utils.strip_prompt_lines","text":"Strips all prompt lines. Source code in fixieai/agents/utils.py 14 15 16 17 18 def strip_prompt_lines ( agent : code_shot . CodeShotAgent ): \"\"\"Strips all prompt lines.\"\"\" agent . base_prompt = _strip_all_lines ( agent . base_prompt ) for i , fewshot in enumerate ( agent . few_shots ): agent . few_shots [ i ] = _strip_all_lines ( fewshot )","title":"strip_prompt_lines()"},{"location":"python-agent-api/#fixieai.agents.utils.validate_code_shot_agent","text":"A client-side validation of few_shots and agent. Source code in fixieai/agents/utils.py 21 22 23 24 25 26 27 def validate_code_shot_agent ( agent : code_shot . CodeShotAgent ): \"\"\"A client-side validation of few_shots and agent.\"\"\" _validate_base_prompt ( agent . base_prompt ) for fewshot in agent . few_shots : _validate_few_shot_prompt ( fewshot , agent . conversational , agent . is_valid_func_name )","title":"validate_code_shot_agent()"},{"location":"python-client-api/","text":"Fixie Client Python API Reference FixieClient FixieClient is a client to the Fixie system. Parameters: api_key ( Optional [ str ] ) \u2013 The API key for the Fixie API server. If not provided, the FIXIE_API_KEY environment variable will be used. If that is not set, the authenticated user API key will be used, or a ValueError will be raised if the user is not authenticated. Source code in fixieai/client/client.py 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 class FixieClient : \"\"\"FixieClient is a client to the Fixie system. Args: api_key: The API key for the Fixie API server. If not provided, the FIXIE_API_KEY environment variable will be used. If that is not set, the authenticated user API key will be used, or a ValueError will be raised if the user is not authenticated. \"\"\" def __init__ ( self , api_key : Optional [ str ] = None , ): self . _api_key = api_key or constants . fixie_api_key () logging . info ( f \"Using Fixie API URL: { constants . FIXIE_API_URL } \" ) self . _request_headers = { \"Authorization\" : f \"Bearer { self . _api_key } \" } transport = RequestsHTTPTransport ( url = constants . FIXIE_GRAPHQL_URL , headers = self . _request_headers , ) self . _rest_client = requests . Session () self . _gqlclient = Client ( transport = transport , fetch_schema_from_transport = False ) @property def gqlclient ( self ) -> Client : \"\"\"Return the underlying GraphQL client used by this FixieClient.\"\"\" return self . _gqlclient @property def url ( self ) -> str : \"\"\"Return the URL of the Fixie API server.\"\"\" return constants . FIXIE_API_URL def get_agents ( self ) -> Dict [ str , Dict [ str , str ]]: \"\"\"Return metadata about all running Fixie Agents. The keys of the returned dictionary are the Agent handles, and the values are dictionaries containing metadata about each Agent.\"\"\" query = gql ( \"\"\" query getAgents { allAgents { agentId name description moreInfoUrl } } \"\"\" ) result = self . _gqlclient . execute ( query ) assert \"allAgents\" in result and isinstance ( result [ \"allAgents\" ], list ) agents = result [ \"allAgents\" ] return { agent [ \"agentId\" ]: agent for agent in agents } def get_agent ( self , agent_id : str ) -> Agent : \"\"\"Return an existing Agent object.\"\"\" return Agent ( self , agent_id ) def get_agent_page_url ( self , agent_id : str ) -> str : \"\"\"Return the URL of the Agent page on the Fixie Platform.\"\"\" return f \" { constants . FIXIE_WEB_AGENT_URL } / { agent_id } \" def create_agent ( self , handle : str , name : str , description : str , query_url : Optional [ str ] = None , func_url : Optional [ str ] = None , more_info_url : Optional [ str ] = None , published : Optional [ bool ] = None , ) -> Agent : \"\"\"Create a new Agent. Args: handle: The handle for the new Agent. This must be unique across all Agents owned by this user. name: The name of the new Agent. description: A description of the new Agent. query_url: (deprecated) Unused. func_url: (deprecated) The URL of the new Agent's func endpoint. more_info_url: A URL with more information about the new Agent. published: Whether the new Agent should be published. \"\"\" agent = Agent ( self , f \" { self . get_current_username () } / { handle } \" ) agent . create_agent ( name , description , query_url , func_url , more_info_url , published ) return agent def get_sessions ( self ) -> List [ str ]: \"\"\"Return a list of all session IDs.\"\"\" query = gql ( \"\"\" query getSessions { allSessions { handle } } \"\"\" ) result = self . _gqlclient . execute ( query ) assert \"allSessions\" in result and isinstance ( result [ \"allSessions\" ], list ) sessions = result [ \"allSessions\" ] return [ session [ \"handle\" ] for session in sessions ] def create_session ( self , frontend_agent_id : Optional [ str ] = None ) -> Session : \"\"\"Create a new Session.\"\"\" return Session ( self , frontend_agent_id = frontend_agent_id ) def get_session ( self , session_id : str ) -> Session : \"\"\"Return an existing Session object.\"\"\" return Session ( self , session_id ) def get_current_user ( self ) -> Dict [ str , Any ]: \"\"\"Returns the user metadata of the current user.\"\"\" query = gql ( \"\"\" query getUsername { user { username firstName lastName email organization { handle name } dailyQueryLimit dailyUsedQueries avatar } } \"\"\" ) result = self . _gqlclient . execute ( query ) assert \"user\" in result and isinstance ( result [ \"user\" ], dict ) return result [ \"user\" ] def get_current_username ( self ) -> str : \"\"\"Returns the username of the current user.\"\"\" user = self . get_current_user () assert \"username\" in user and isinstance ( user [ \"username\" ], str ) return user [ \"username\" ] def refresh_agent ( self , agent_handle : str ): \"\"\"Indicates that an agent's prompts should be refreshed.\"\"\" username = self . get_current_username () self . post ( f \" { constants . FIXIE_REFRESH_URL } / { username } / { agent_handle } \" ) def create_agent_revision ( self , handle : str , make_current : bool , * , reindex_corpora : bool = False , metadata : Optional [ Dict [ str , str ]] = None , external_url : Optional [ str ] = None , gzip_tarfile : Optional [ BinaryIO ] = None , environment : FixieEnvironment = FixieEnvironment . PYTHON , ) -> str : \"\"\"Creates a new Agent revision. Args: handle: The handle of the Agent. Must be owned by the current user. make_current: Whether the new revision should be made the current (active) revision. reindex_corpora: Whether to reindex all corpora for the new revision. metadata: Optional client-provided metadata to associate with the revision. external_url: The URL at which the revision is hosted, if hosted externally. gzip_tarfile: A file-like of a gzip-compressed tarfile containing the files to deploy. environment: The environment in which the revision should be run. Exactly one of `external_url` and `gzip_tarfile` must be provided. \"\"\" mutation = gql ( \"\"\" mutation CreateAgentRevision( $handle: String!, $metadata: [RevisionMetadataKeyValuePairInput!]!, $makeCurrent: Boolean!, $externalDeployment: ExternalDeploymentInput, $managedDeployment: ManagedDeploymentInput, $reindexCorpora: Boolean!, ) { createAgentRevision(agentHandle: $handle, makeCurrent: $makeCurrent, revision: { metadata: $metadata externalDeployment: $externalDeployment managedDeployment: $managedDeployment }, reindexCorpora: $reindexCorpora) { revision { id } } } \"\"\" ) with utils . patched_gql_file_uploader ( gzip_tarfile , \"upload.tar.gz\" , \"application/gzip\" ): result = self . _gqlclient . execute ( mutation , variable_values = { \"handle\" : handle , \"metadata\" : [ { \"key\" : key , \"value\" : value } for key , value in metadata . items () ] if metadata else [], \"makeCurrent\" : make_current , \"reindexCorpora\" : reindex_corpora , \"externalDeployment\" : { \"url\" : external_url } if external_url else None , \"managedDeployment\" : { \"environment\" : environment , \"codePackage\" : gzip_tarfile , } if gzip_tarfile else None , }, upload_files = True , ) revision_id = result [ \"createAgentRevision\" ][ \"revision\" ][ \"id\" ] assert isinstance ( revision_id , str ) return revision_id def get_current_agent_revision ( self , handle : str ) -> Optional [ str ]: \"\"\"Gets the current (active) revision of an agent.\"\"\" agent = self . get_agent ( handle ) query = gql ( \"\"\" query GetRevisionId($agentId: String!) { agentById(agentId: $agentId) { currentRevision { id } } } \"\"\" ) response = self . _gqlclient . execute ( query , variable_values = { \"agentId\" : agent . agent_id }, ) revision = response [ \"agentById\" ][ \"currentRevision\" ] return revision [ \"id\" ] if revision is not None else None def set_current_agent_revision ( self , handle : str , revision_id : str ): \"\"\"Sets the current (active) revision of an agent.\"\"\" mutation = gql ( \"\"\" mutation SetCurrentAgentRevision( $handle: String!, $currentRevisionId: ID!) { updateAgent( agentData: { handle: $handle, currentRevisionId: $currentRevisionId } ) { agent { agentId } } } \"\"\" ) _ = self . _gqlclient . execute ( mutation , variable_values = { \"handle\" : handle , \"currentRevisionId\" : revision_id }, ) def delete_agent_revision ( self , handle : str , revision_id : str ): \"\"\"Deletes an Agent revision.\"\"\" mutation = gql ( \"\"\" mutation DeleteRevision($handle: String!, $revisionId: ID!) { deleteAgentRevision(agentHandle: $handle, revisionId: $revisionId) { agent { agentId } } } \"\"\" ) _ = self . _gqlclient . execute ( mutation , variable_values = { \"handle\" : handle , \"revisionId\" : revision_id } ) def deploy_agent ( self , handle : str , gzip_tarfile : BinaryIO , environment : FixieEnvironment ): \"\"\"Deploys an agent implementation. Args: handle: The handle of the Agent to deploy. Must be owned by the current user. gzip_tarfile: A file-like of a gzip-compressed tarfile containing the files to deploy. \"\"\" return self . create_agent_revision ( handle , make_current = True , gzip_tarfile = gzip_tarfile , environment = environment , ) def post ( self , url : str , data : Optional [ Dict [ str , Any ]] = None ) -> Any : \"\"\"Performs a POST request with the appropriate auth token. The response will be parsed as JSON and returned. Args: url: The URL to POST to, which should start with https://api.fixie.ai/api data: The data to send in the request body (optional) \"\"\" assert url . startswith ( constants . FIXIE_API_URL ) response = self . _rest_client . post ( url , headers = self . _request_headers , json = data ) response . raise_for_status () return response . json () def streaming_post ( self , url : str , data : Optional [ Dict [ str , Any ]] = None ) -> Generator [ Any , None , None ]: \"\"\"Performs a POST request with the appropriate auth token, and handles a streaming response. The response will be yielded as a generator of JSON objects, one per line. Args: url: The URL to POST to, which should start with https://api.fixie.ai/api data: The data to send in the request body (optional) \"\"\" assert url . startswith ( constants . FIXIE_API_URL ) response = self . _rest_client . post ( url , headers = self . _request_headers , json = data , stream = True ) response . raise_for_status () return ( json . loads ( line ) for line in response . iter_lines () if line ) gqlclient : Client property Return the underlying GraphQL client used by this FixieClient. url : str property Return the URL of the Fixie API server. create_agent ( handle , name , description , query_url = None , func_url = None , more_info_url = None , published = None ) Create a new Agent. Parameters: handle ( str ) \u2013 The handle for the new Agent. This must be unique across all Agents owned by this user. name ( str ) \u2013 The name of the new Agent. description ( str ) \u2013 A description of the new Agent. query_url ( Optional [ str ] ) \u2013 (deprecated) Unused. func_url ( Optional [ str ] ) \u2013 (deprecated) The URL of the new Agent's func endpoint. more_info_url ( Optional [ str ] ) \u2013 A URL with more information about the new Agent. published ( Optional [ bool ] ) \u2013 Whether the new Agent should be published. Source code in fixieai/client/client.py 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 def create_agent ( self , handle : str , name : str , description : str , query_url : Optional [ str ] = None , func_url : Optional [ str ] = None , more_info_url : Optional [ str ] = None , published : Optional [ bool ] = None , ) -> Agent : \"\"\"Create a new Agent. Args: handle: The handle for the new Agent. This must be unique across all Agents owned by this user. name: The name of the new Agent. description: A description of the new Agent. query_url: (deprecated) Unused. func_url: (deprecated) The URL of the new Agent's func endpoint. more_info_url: A URL with more information about the new Agent. published: Whether the new Agent should be published. \"\"\" agent = Agent ( self , f \" { self . get_current_username () } / { handle } \" ) agent . create_agent ( name , description , query_url , func_url , more_info_url , published ) return agent create_agent_revision ( handle , make_current , * , reindex_corpora = False , metadata = None , external_url = None , gzip_tarfile = None , environment = FixieEnvironment . PYTHON ) Creates a new Agent revision. Parameters: handle ( str ) \u2013 The handle of the Agent. Must be owned by the current user. make_current ( bool ) \u2013 Whether the new revision should be made the current (active) revision. reindex_corpora ( bool ) \u2013 Whether to reindex all corpora for the new revision. metadata ( Optional [ Dict [ str , str ]] ) \u2013 Optional client-provided metadata to associate with the revision. external_url ( Optional [ str ] ) \u2013 The URL at which the revision is hosted, if hosted externally. gzip_tarfile ( Optional [ BinaryIO ] ) \u2013 A file-like of a gzip-compressed tarfile containing the files to deploy. environment ( FixieEnvironment ) \u2013 The environment in which the revision should be run. Exactly one of external_url and gzip_tarfile must be provided. Source code in fixieai/client/client.py 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 def create_agent_revision ( self , handle : str , make_current : bool , * , reindex_corpora : bool = False , metadata : Optional [ Dict [ str , str ]] = None , external_url : Optional [ str ] = None , gzip_tarfile : Optional [ BinaryIO ] = None , environment : FixieEnvironment = FixieEnvironment . PYTHON , ) -> str : \"\"\"Creates a new Agent revision. Args: handle: The handle of the Agent. Must be owned by the current user. make_current: Whether the new revision should be made the current (active) revision. reindex_corpora: Whether to reindex all corpora for the new revision. metadata: Optional client-provided metadata to associate with the revision. external_url: The URL at which the revision is hosted, if hosted externally. gzip_tarfile: A file-like of a gzip-compressed tarfile containing the files to deploy. environment: The environment in which the revision should be run. Exactly one of `external_url` and `gzip_tarfile` must be provided. \"\"\" mutation = gql ( \"\"\" mutation CreateAgentRevision( $handle: String!, $metadata: [RevisionMetadataKeyValuePairInput!]!, $makeCurrent: Boolean!, $externalDeployment: ExternalDeploymentInput, $managedDeployment: ManagedDeploymentInput, $reindexCorpora: Boolean!, ) { createAgentRevision(agentHandle: $handle, makeCurrent: $makeCurrent, revision: { metadata: $metadata externalDeployment: $externalDeployment managedDeployment: $managedDeployment }, reindexCorpora: $reindexCorpora) { revision { id } } } \"\"\" ) with utils . patched_gql_file_uploader ( gzip_tarfile , \"upload.tar.gz\" , \"application/gzip\" ): result = self . _gqlclient . execute ( mutation , variable_values = { \"handle\" : handle , \"metadata\" : [ { \"key\" : key , \"value\" : value } for key , value in metadata . items () ] if metadata else [], \"makeCurrent\" : make_current , \"reindexCorpora\" : reindex_corpora , \"externalDeployment\" : { \"url\" : external_url } if external_url else None , \"managedDeployment\" : { \"environment\" : environment , \"codePackage\" : gzip_tarfile , } if gzip_tarfile else None , }, upload_files = True , ) revision_id = result [ \"createAgentRevision\" ][ \"revision\" ][ \"id\" ] assert isinstance ( revision_id , str ) return revision_id create_session ( frontend_agent_id = None ) Create a new Session. Source code in fixieai/client/client.py 174 175 176 def create_session ( self , frontend_agent_id : Optional [ str ] = None ) -> Session : \"\"\"Create a new Session.\"\"\" return Session ( self , frontend_agent_id = frontend_agent_id ) delete_agent_revision ( handle , revision_id ) Deletes an Agent revision. Source code in fixieai/client/client.py 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 def delete_agent_revision ( self , handle : str , revision_id : str ): \"\"\"Deletes an Agent revision.\"\"\" mutation = gql ( \"\"\" mutation DeleteRevision($handle: String!, $revisionId: ID!) { deleteAgentRevision(agentHandle: $handle, revisionId: $revisionId) { agent { agentId } } } \"\"\" ) _ = self . _gqlclient . execute ( mutation , variable_values = { \"handle\" : handle , \"revisionId\" : revision_id } ) deploy_agent ( handle , gzip_tarfile , environment ) Deploys an agent implementation. Parameters: handle ( str ) \u2013 The handle of the Agent to deploy. Must be owned by the current user. gzip_tarfile ( BinaryIO ) \u2013 A file-like of a gzip-compressed tarfile containing the files to deploy. Source code in fixieai/client/client.py 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 def deploy_agent ( self , handle : str , gzip_tarfile : BinaryIO , environment : FixieEnvironment ): \"\"\"Deploys an agent implementation. Args: handle: The handle of the Agent to deploy. Must be owned by the current user. gzip_tarfile: A file-like of a gzip-compressed tarfile containing the files to deploy. \"\"\" return self . create_agent_revision ( handle , make_current = True , gzip_tarfile = gzip_tarfile , environment = environment , ) get_agent ( agent_id ) Return an existing Agent object. Source code in fixieai/client/client.py 121 122 123 def get_agent ( self , agent_id : str ) -> Agent : \"\"\"Return an existing Agent object.\"\"\" return Agent ( self , agent_id ) get_agent_page_url ( agent_id ) Return the URL of the Agent page on the Fixie Platform. Source code in fixieai/client/client.py 125 126 127 def get_agent_page_url ( self , agent_id : str ) -> str : \"\"\"Return the URL of the Agent page on the Fixie Platform.\"\"\" return f \" { constants . FIXIE_WEB_AGENT_URL } / { agent_id } \" get_agents () Return metadata about all running Fixie Agents. The keys of the returned dictionary are the Agent handles, and the values are dictionaries containing metadata about each Agent. Source code in fixieai/client/client.py 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 def get_agents ( self ) -> Dict [ str , Dict [ str , str ]]: \"\"\"Return metadata about all running Fixie Agents. The keys of the returned dictionary are the Agent handles, and the values are dictionaries containing metadata about each Agent.\"\"\" query = gql ( \"\"\" query getAgents { allAgents { agentId name description moreInfoUrl } } \"\"\" ) result = self . _gqlclient . execute ( query ) assert \"allAgents\" in result and isinstance ( result [ \"allAgents\" ], list ) agents = result [ \"allAgents\" ] return { agent [ \"agentId\" ]: agent for agent in agents } get_current_agent_revision ( handle ) Gets the current (active) revision of an agent. Source code in fixieai/client/client.py 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 def get_current_agent_revision ( self , handle : str ) -> Optional [ str ]: \"\"\"Gets the current (active) revision of an agent.\"\"\" agent = self . get_agent ( handle ) query = gql ( \"\"\" query GetRevisionId($agentId: String!) { agentById(agentId: $agentId) { currentRevision { id } } } \"\"\" ) response = self . _gqlclient . execute ( query , variable_values = { \"agentId\" : agent . agent_id }, ) revision = response [ \"agentById\" ][ \"currentRevision\" ] return revision [ \"id\" ] if revision is not None else None get_current_user () Returns the user metadata of the current user. Source code in fixieai/client/client.py 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 def get_current_user ( self ) -> Dict [ str , Any ]: \"\"\"Returns the user metadata of the current user.\"\"\" query = gql ( \"\"\" query getUsername { user { username firstName lastName email organization { handle name } dailyQueryLimit dailyUsedQueries avatar } } \"\"\" ) result = self . _gqlclient . execute ( query ) assert \"user\" in result and isinstance ( result [ \"user\" ], dict ) return result [ \"user\" ] get_current_username () Returns the username of the current user. Source code in fixieai/client/client.py 207 208 209 210 211 def get_current_username ( self ) -> str : \"\"\"Returns the username of the current user.\"\"\" user = self . get_current_user () assert \"username\" in user and isinstance ( user [ \"username\" ], str ) return user [ \"username\" ] get_session ( session_id ) Return an existing Session object. Source code in fixieai/client/client.py 178 179 180 def get_session ( self , session_id : str ) -> Session : \"\"\"Return an existing Session object.\"\"\" return Session ( self , session_id ) get_sessions () Return a list of all session IDs. Source code in fixieai/client/client.py 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 def get_sessions ( self ) -> List [ str ]: \"\"\"Return a list of all session IDs.\"\"\" query = gql ( \"\"\" query getSessions { allSessions { handle } } \"\"\" ) result = self . _gqlclient . execute ( query ) assert \"allSessions\" in result and isinstance ( result [ \"allSessions\" ], list ) sessions = result [ \"allSessions\" ] return [ session [ \"handle\" ] for session in sessions ] post ( url , data = None ) Performs a POST request with the appropriate auth token. The response will be parsed as JSON and returned. Parameters: url ( str ) \u2013 The URL to POST to, which should start with https://api.fixie.ai/api data ( Optional [ Dict [ str , Any ]] ) \u2013 The data to send in the request body (optional) Source code in fixieai/client/client.py 381 382 383 384 385 386 387 388 389 390 391 392 def post ( self , url : str , data : Optional [ Dict [ str , Any ]] = None ) -> Any : \"\"\"Performs a POST request with the appropriate auth token. The response will be parsed as JSON and returned. Args: url: The URL to POST to, which should start with https://api.fixie.ai/api data: The data to send in the request body (optional) \"\"\" assert url . startswith ( constants . FIXIE_API_URL ) response = self . _rest_client . post ( url , headers = self . _request_headers , json = data ) response . raise_for_status () return response . json () refresh_agent ( agent_handle ) Indicates that an agent's prompts should be refreshed. Source code in fixieai/client/client.py 213 214 215 216 def refresh_agent ( self , agent_handle : str ): \"\"\"Indicates that an agent's prompts should be refreshed.\"\"\" username = self . get_current_username () self . post ( f \" { constants . FIXIE_REFRESH_URL } / { username } / { agent_handle } \" ) set_current_agent_revision ( handle , revision_id ) Sets the current (active) revision of an agent. Source code in fixieai/client/client.py 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 def set_current_agent_revision ( self , handle : str , revision_id : str ): \"\"\"Sets the current (active) revision of an agent.\"\"\" mutation = gql ( \"\"\" mutation SetCurrentAgentRevision( $handle: String!, $currentRevisionId: ID!) { updateAgent( agentData: { handle: $handle, currentRevisionId: $currentRevisionId } ) { agent { agentId } } } \"\"\" ) _ = self . _gqlclient . execute ( mutation , variable_values = { \"handle\" : handle , \"currentRevisionId\" : revision_id }, ) streaming_post ( url , data = None ) Performs a POST request with the appropriate auth token, and handles a streaming response. The response will be yielded as a generator of JSON objects, one per line. Parameters: url ( str ) \u2013 The URL to POST to, which should start with https://api.fixie.ai/api data ( Optional [ Dict [ str , Any ]] ) \u2013 The data to send in the request body (optional) Source code in fixieai/client/client.py 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 def streaming_post ( self , url : str , data : Optional [ Dict [ str , Any ]] = None ) -> Generator [ Any , None , None ]: \"\"\"Performs a POST request with the appropriate auth token, and handles a streaming response. The response will be yielded as a generator of JSON objects, one per line. Args: url: The URL to POST to, which should start with https://api.fixie.ai/api data: The data to send in the request body (optional) \"\"\" assert url . startswith ( constants . FIXIE_API_URL ) response = self . _rest_client . post ( url , headers = self . _request_headers , json = data , stream = True ) response . raise_for_status () return ( json . loads ( line ) for line in response . iter_lines () if line ) get_agents () Return metadata about all Fixie Agents. The keys of the returned dictionary are Agent IDs, and the values are dictionaries containing metadata about each Agent. Source code in fixieai/client/client.py 48 49 50 51 52 def get_agents () -> Dict [ str , Dict [ str , str ]]: \"\"\"Return metadata about all Fixie Agents. The keys of the returned dictionary are Agent IDs, and the values are dictionaries containing metadata about each Agent.\"\"\" return get_client () . get_agents () get_client () Return the global FixieClient instance. Source code in fixieai/client/client.py 30 31 32 33 34 35 36 def get_client () -> FixieClient : \"\"\"Return the global FixieClient instance.\"\"\" global _CLIENT if not _CLIENT : _CLIENT = FixieClient () assert _CLIENT is not None return _CLIENT get_embeds () Return a list of Embeds. Source code in fixieai/client/client.py 60 61 62 def get_embeds () -> List [ Dict [ str , Any ]]: \"\"\"Return a list of Embeds.\"\"\" return get_session () . get_embeds () get_session () Return the global Fixie Session instance. Source code in fixieai/client/client.py 39 40 41 42 43 44 45 def get_session () -> Session : \"\"\"Return the global Fixie Session instance.\"\"\" global _SESSION if not _SESSION : _SESSION = Session ( get_client ()) assert _SESSION is not None return _SESSION query ( text ) Run a query. Source code in fixieai/client/client.py 55 56 57 def query ( text : str ) -> str : \"\"\"Run a query.\"\"\" return get_session () . query ( text ) Session Represents a single session with the Fixie system. Parameters: client ( FixieClient ) \u2013 The FixieClient instance to use. session_id ( Optional [ str ] ) \u2013 The ID of the session to use. If not provided, a new session will be created. Source code in fixieai/client/session.py 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 class Session : \"\"\"Represents a single session with the Fixie system. Args: client: The FixieClient instance to use. session_id: The ID of the session to use. If not provided, a new session will be created. \"\"\" def __init__ ( self , client : FixieClient , session_id : Optional [ str ] = None , frontend_agent_id : Optional [ str ] = None , ): self . _client = client self . _gqlclient = self . _client . gqlclient self . _session_id = session_id self . _frontend_agent_id = frontend_agent_id if session_id : # Test that the session exists. _ = self . get_metadata () assert ( frontend_agent_id is None ), \"Cannot specify frontend_agent_id when using an existing session\" else : self . _session_id = self . _create_session ( frontend_agent_id ) @property def session_id ( self ) -> Optional [ str ]: \"\"\"Return the session ID used by this Fixie client.\"\"\" return self . _session_id @property def session_url ( self ) -> str : \"\"\"Return the URL of the Fixie session.\"\"\" return f \" { self . _client . url } /sessions/ { self . session_id } \" @property def frontend_agent_id ( self ) -> Optional [ str ]: \"\"\"Return the frontend agent ID used by this Fixie client.\"\"\" return self . _frontend_agent_id def _create_session ( self , frontend_agent_id : Optional [ str ] = None ) -> str : \"\"\"Create a new session.\"\"\" assert self . _session_id is None query = gql ( \"\"\" mutation CreateSession($frontendAgentId: String) { createSession(sessionData: {frontendAgentId: $frontendAgentId}) { session { handle frontendAgentId } } } \"\"\" ) result = self . _gqlclient . execute ( query , variable_values = { \"frontendAgentId\" : frontend_agent_id } ) if \"createSession\" not in result or result [ \"createSession\" ] is None : raise ValueError ( f \"Failed to create Session\" ) assert isinstance ( result [ \"createSession\" ], dict ) assert isinstance ( result [ \"createSession\" ][ \"session\" ], dict ) assert isinstance ( result [ \"createSession\" ][ \"session\" ][ \"handle\" ], str ) return result [ \"createSession\" ][ \"session\" ][ \"handle\" ] def get_metadata ( self ) -> Dict [ str , Any ]: \"\"\"Return metadata about this session.\"\"\" query = gql ( \"\"\" query getSession($session_id: String!) { sessionByHandle(handle: $session_id) { handle name description frontendAgentId } } \"\"\" ) result = self . _gqlclient . execute ( query , variable_values = { \"session_id\" : self . _session_id } ) assert \"sessionByHandle\" in result and isinstance ( result [ \"sessionByHandle\" ], dict ) self . _frontend_agent_id = result [ \"sessionByHandle\" ][ \"frontendAgentId\" ] return result [ \"sessionByHandle\" ] def delete_session ( self ) -> None : \"\"\"Delete the current session.\"\"\" query = gql ( \"\"\" mutation DeleteSession($handle: String!) { deleteSession(handle: $handle) { session { handle } } } \"\"\" ) _ = self . _gqlclient . execute ( query , variable_values = { \"handle\" : self . _session_id }) def get_embeds ( self ) -> List [ Dict [ str , Any ]]: \"\"\"Return the Embeds attached to this Session.\"\"\" query = gql ( \"\"\" query getEmbeds($handle: String!) { sessionByHandle(handle: $handle) { embeds { key embed { id contentType created contentHash owner { username } url } } } } \"\"\" ) result = self . _gqlclient . execute ( query , variable_values = { \"handle\" : self . _session_id } ) assert ( \"sessionByHandle\" in result and isinstance ( result [ \"sessionByHandle\" ], dict ) and isinstance ( result [ \"sessionByHandle\" ][ \"embeds\" ], list ) ) return result [ \"sessionByHandle\" ][ \"embeds\" ] def get_messages ( self ) -> List [ Dict [ str , Any ]]: \"\"\"Return the messages that make up this session.\"\"\" query = gql ( \"\"\" query getMessages($handle: String!) { sessionByHandle(handle: $handle) { messages { id text sentBy { handle } type inReplyTo { id } timestamp } } } \"\"\" ) result = self . _gqlclient . execute ( query , variable_values = { \"handle\" : self . _session_id } ) assert ( \"sessionByHandle\" in result and isinstance ( result [ \"sessionByHandle\" ], dict ) and isinstance ( result [ \"sessionByHandle\" ][ \"messages\" ], list ) ) return result [ \"sessionByHandle\" ][ \"messages\" ] def query ( self , text : str ) -> str : \"\"\"Run a single query against the Fixie API and return the response.\"\"\" final = \"\" for message in self . streaming_query ( text ): final = message [ \"text\" ] return final def streaming_query ( self , text : str ) -> Generator [ Dict [ str , Any ], None , None ]: \"\"\"Run a single query against the Fixie API and return a stream.\"\"\" data = { \"session\" : self . _session_id , \"message\" : { \"text\" : text }, \"stream\" : True , } url = f \" { constants . FIXIE_AGENT_URL } / { self . _frontend_agent_id } \" for response in self . _client . streaming_post ( url , data ): yield { \"text\" : response [ \"message\" ][ \"text\" ], \"type\" : response [ \"type\" ], } frontend_agent_id : Optional [ str ] property Return the frontend agent ID used by this Fixie client. session_id : Optional [ str ] property Return the session ID used by this Fixie client. session_url : str property Return the URL of the Fixie session. delete_session () Delete the current session. Source code in fixieai/client/session.py 113 114 115 116 117 118 119 120 121 122 123 124 125 126 def delete_session ( self ) -> None : \"\"\"Delete the current session.\"\"\" query = gql ( \"\"\" mutation DeleteSession($handle: String!) { deleteSession(handle: $handle) { session { handle } } } \"\"\" ) _ = self . _gqlclient . execute ( query , variable_values = { \"handle\" : self . _session_id }) get_embeds () Return the Embeds attached to this Session. Source code in fixieai/client/session.py 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 def get_embeds ( self ) -> List [ Dict [ str , Any ]]: \"\"\"Return the Embeds attached to this Session.\"\"\" query = gql ( \"\"\" query getEmbeds($handle: String!) { sessionByHandle(handle: $handle) { embeds { key embed { id contentType created contentHash owner { username } url } } } } \"\"\" ) result = self . _gqlclient . execute ( query , variable_values = { \"handle\" : self . _session_id } ) assert ( \"sessionByHandle\" in result and isinstance ( result [ \"sessionByHandle\" ], dict ) and isinstance ( result [ \"sessionByHandle\" ][ \"embeds\" ], list ) ) return result [ \"sessionByHandle\" ][ \"embeds\" ] get_messages () Return the messages that make up this session. Source code in fixieai/client/session.py 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 def get_messages ( self ) -> List [ Dict [ str , Any ]]: \"\"\"Return the messages that make up this session.\"\"\" query = gql ( \"\"\" query getMessages($handle: String!) { sessionByHandle(handle: $handle) { messages { id text sentBy { handle } type inReplyTo { id } timestamp } } } \"\"\" ) result = self . _gqlclient . execute ( query , variable_values = { \"handle\" : self . _session_id } ) assert ( \"sessionByHandle\" in result and isinstance ( result [ \"sessionByHandle\" ], dict ) and isinstance ( result [ \"sessionByHandle\" ][ \"messages\" ], list ) ) return result [ \"sessionByHandle\" ][ \"messages\" ] get_metadata () Return metadata about this session. Source code in fixieai/client/session.py 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 def get_metadata ( self ) -> Dict [ str , Any ]: \"\"\"Return metadata about this session.\"\"\" query = gql ( \"\"\" query getSession($session_id: String!) { sessionByHandle(handle: $session_id) { handle name description frontendAgentId } } \"\"\" ) result = self . _gqlclient . execute ( query , variable_values = { \"session_id\" : self . _session_id } ) assert \"sessionByHandle\" in result and isinstance ( result [ \"sessionByHandle\" ], dict ) self . _frontend_agent_id = result [ \"sessionByHandle\" ][ \"frontendAgentId\" ] return result [ \"sessionByHandle\" ] query ( text ) Run a single query against the Fixie API and return the response. Source code in fixieai/client/session.py 191 192 193 194 195 196 def query ( self , text : str ) -> str : \"\"\"Run a single query against the Fixie API and return the response.\"\"\" final = \"\" for message in self . streaming_query ( text ): final = message [ \"text\" ] return final streaming_query ( text ) Run a single query against the Fixie API and return a stream. Source code in fixieai/client/session.py 198 199 200 201 202 203 204 205 206 207 208 209 210 def streaming_query ( self , text : str ) -> Generator [ Dict [ str , Any ], None , None ]: \"\"\"Run a single query against the Fixie API and return a stream.\"\"\" data = { \"session\" : self . _session_id , \"message\" : { \"text\" : text }, \"stream\" : True , } url = f \" { constants . FIXIE_AGENT_URL } / { self . _frontend_agent_id } \" for response in self . _client . streaming_post ( url , data ): yield { \"text\" : response [ \"message\" ][ \"text\" ], \"type\" : response [ \"type\" ], } Agent Provides an interface to the Fixie GraphQL Agent API. Parameters: client ( FixieClient ) \u2013 The FixieClient instance to use. agent_id ( str ) \u2013 The Agent ID, e.g., \"fixie/calc\", or handle, e.g., \"dice\". Source code in fixieai/client/agent.py 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 class Agent : \"\"\"Provides an interface to the Fixie GraphQL Agent API. Args: client: The FixieClient instance to use. agent_id: The Agent ID, e.g., \"fixie/calc\", or handle, e.g., \"dice\". \"\"\" def __init__ ( self , client : FixieClient , agent_id : str , ): self . _client = client self . _gqlclient = self . _client . gqlclient self . _agent_id = agent_id self . _owner : Optional [ str ] = None if \"/\" in agent_id : self . _owner , self . _handle = agent_id . split ( \"/\" ) else : self . _owner = self . _client . get_current_username () self . _handle = agent_id self . _metadata : Optional [ Dict [ str , Any ]] = None try : self . _metadata = self . get_metadata () except : self . _metadata = None @property def agent_id ( self ) -> str : \"\"\"Return the agentId for this Agent.\"\"\" return self . _agent_id @property def handle ( self ) -> str : \"\"\"Return the handle for this Agent.\"\"\" return self . _handle @property def valid ( self ) -> bool : \"\"\"Return whether this Agent is valid.\"\"\" return self . _metadata is not None @property def name ( self ) -> Optional [ str ]: \"\"\"Return the name for this Agent.\"\"\" if self . _metadata is None : return None name = self . _metadata [ \"name\" ] assert name is None or isinstance ( name , str ) return name @property def description ( self ) -> Optional [ str ]: \"\"\"Return the description for this Agent.\"\"\" if self . _metadata is None : return None description = self . _metadata [ \"description\" ] assert description is None or isinstance ( description , str ) return description @property def queries ( self ) -> Optional [ List [ str ]]: \"\"\"Return the queries for this Agent.\"\"\" if self . _metadata is None : return None queries = self . _metadata [ \"queries\" ] assert queries is None or ( isinstance ( queries , list ) and all ( isinstance ( q , str ) for q in queries ) ) return queries @property def more_info_url ( self ) -> Optional [ str ]: \"\"\"Return the more info URL for this Agent.\"\"\" if self . _metadata is None : return None more_info_url = self . _metadata [ \"moreInfoUrl\" ] assert more_info_url is None or isinstance ( more_info_url , str ) return more_info_url @property def published ( self ) -> Optional [ bool ]: \"\"\"Return the published status for this Agent.\"\"\" if self . _metadata is None : return None published = self . _metadata [ \"published\" ] assert published is None or isinstance ( published , bool ) return published @property def owner ( self ) -> Optional [ str ]: \"\"\"Return the owner of this Agent, which is either a username or an Organization handle.\"\"\" if self . _metadata is None : return None owner_username = self . _metadata [ \"owner\" ] . get ( \"username\" ) or self . _metadata [ \"owner\" ] . get ( \"handle\" ) assert owner_username is None or isinstance ( owner_username , str ) return owner_username @property def query_url ( self ) -> Optional [ str ]: \"\"\"Return the query URL for this Agent.\"\"\" if self . _metadata is None : return None url = self . _metadata [ \"queryUrl\" ] assert url is None or isinstance ( url , str ) return url @property def func_url ( self ) -> Optional [ str ]: \"\"\"Return the func URL for this Agent.\"\"\" if self . _metadata is None : return None url = self . _metadata [ \"funcUrl\" ] assert url is None or isinstance ( url , str ) return url @property def created ( self ) -> Optional [ datetime . datetime ]: \"\"\"Return the creation timestamp for this Agent.\"\"\" if self . _metadata is None : return None ts = self . _metadata [ \"created\" ] if ts is not None : return datetime . datetime . fromisoformat ( ts ) else : return None @property def modified ( self ) -> Optional [ datetime . datetime ]: \"\"\"Return the modification timestamp for this Agent.\"\"\" if self . _metadata is None : return None ts = self . _metadata [ \"modified\" ] if ts is not None : return datetime . datetime . fromisoformat ( ts ) else : return None def get_metadata ( self ) -> Dict [ str , Any ]: \"\"\"Return metadata about this Agent.\"\"\" query = gql ( \"\"\" query getAgentById($agentId: String!) { agentById(agentId: $agentId) { agentId handle name description queries moreInfoUrl published owner { __typename ... on UserType { username } ... on OrganizationType { handle } } queryUrl funcUrl created modified } } \"\"\" ) result = self . _gqlclient . execute ( query , variable_values = { \"agentId\" : f \" { self . _owner } / { self . _handle } \" } ) if \"agentById\" not in result or result [ \"agentById\" ] is None : raise ValueError ( f \"Cannot fetch agent metadata for { self . _owner } / { self . _handle } \" ) agent_dict = result [ \"agentById\" ] assert isinstance ( agent_dict , dict ) and all ( isinstance ( k , str ) for k in agent_dict . keys () ) return agent_dict def create_agent ( self , name : Optional [ str ], description : str , query_url : Optional [ str ] = None , func_url : Optional [ str ] = None , more_info_url : Optional [ str ] = None , published : Optional [ bool ] = None , ) -> str : \"\"\"Create a new Agent with the given parameters.\"\"\" query = gql ( \"\"\" mutation CreateAgent( $handle: String!, $name: String, $description: String!, $queryUrl: String, $funcUrl: String, $moreInfoUrl: String, $published: Boolean) { createAgent( agentData: { handle: $handle, name: $name, description: $description, queryUrl: $queryUrl, funcUrl: $funcUrl, moreInfoUrl: $moreInfoUrl, published: $published } ) { agent { agentId } } } \"\"\" ) variable_values : Dict [ str , Any ] = { \"handle\" : self . _handle } if name is not None : variable_values [ \"name\" ] = name variable_values [ \"description\" ] = description if query_url is not None : variable_values [ \"queryUrl\" ] = query_url if func_url is not None : warnings . warn ( \"Setting func_url via create_agent is deprecated, use FixieClient.create_agent_revision instead.\" ) variable_values [ \"funcUrl\" ] = func_url if more_info_url is not None : variable_values [ \"moreInfoUrl\" ] = more_info_url if published is not None : variable_values [ \"published\" ] = published result = self . _gqlclient . execute ( query , variable_values = variable_values ) if \"createAgent\" not in result or result [ \"createAgent\" ] is None : raise ValueError ( f \"Failed to create Agent\" ) assert isinstance ( result [ \"createAgent\" ], dict ) assert isinstance ( result [ \"createAgent\" ][ \"agent\" ], dict ) assert isinstance ( result [ \"createAgent\" ][ \"agent\" ][ \"agentId\" ], str ) self . _metadata = self . get_metadata () return result [ \"createAgent\" ][ \"agent\" ][ \"agentId\" ] def update_agent ( self , new_handle : Optional [ str ] = None , name : Optional [ str ] = None , description : Optional [ str ] = None , query_url : Optional [ str ] = None , func_url : Optional [ str ] = None , more_info_url : Optional [ str ] = None , published : Optional [ bool ] = None , ) -> str : \"\"\"Update the Agent with the given parameters.\"\"\" query = gql ( \"\"\" mutation UpdateAgent( $handle: String!, $newHandle: String, $name: String, $description: String, $queryUrl: String, $funcUrl: String, $moreInfoUrl: String, $published: Boolean) { updateAgent( agentData: { handle: $handle, newHandle: $newHandle, name: $name, description: $description, queryUrl: $queryUrl, funcUrl: $funcUrl, moreInfoUrl: $moreInfoUrl, published: $published } ) { agent { agentId } } } \"\"\" ) variable_values : Dict [ str , Any ] = { \"handle\" : self . _handle } if new_handle is not None : variable_values [ \"newHandle\" ] = new_handle if name is not None : variable_values [ \"name\" ] = name if description is not None : variable_values [ \"description\" ] = description if query_url is not None : variable_values [ \"queryUrl\" ] = query_url if func_url is not None : warnings . warn ( \"Setting func_url via update_agent is deprecated, use FixieClient.create_agent_revision instead.\" ) variable_values [ \"funcUrl\" ] = func_url if more_info_url is not None : variable_values [ \"moreInfoUrl\" ] = more_info_url if published is not None : variable_values [ \"published\" ] = published result = self . _gqlclient . execute ( query , variable_values = variable_values ) if \"updateAgent\" not in result or result [ \"updateAgent\" ] is None : raise ValueError ( f \"Failed to update Agent\" ) assert isinstance ( result [ \"updateAgent\" ], dict ) assert isinstance ( result [ \"updateAgent\" ][ \"agent\" ], dict ) assert isinstance ( result [ \"updateAgent\" ][ \"agent\" ][ \"agentId\" ], str ) self . _metadata = self . get_metadata () if new_handle : self . _handle = new_handle return result [ \"updateAgent\" ][ \"agent\" ][ \"agentId\" ] def delete_agent ( self ) -> None : \"\"\"Delete this Agent.\"\"\" query = gql ( \"\"\" mutation DeleteAgent($owner: String!, $handle: String!) { deleteAgent(agentData: {owner: $owner, handle: $handle}) { agent { handle } } } \"\"\" ) _ = self . _gqlclient . execute ( query , variable_values = { \"owner\" : self . owner , \"handle\" : self . _handle } ) agent_id : str property Return the agentId for this Agent. created : Optional [ datetime . datetime ] property Return the creation timestamp for this Agent. description : Optional [ str ] property Return the description for this Agent. func_url : Optional [ str ] property Return the func URL for this Agent. handle : str property Return the handle for this Agent. modified : Optional [ datetime . datetime ] property Return the modification timestamp for this Agent. more_info_url : Optional [ str ] property Return the more info URL for this Agent. name : Optional [ str ] property Return the name for this Agent. owner : Optional [ str ] property Return the owner of this Agent, which is either a username or an Organization handle. published : Optional [ bool ] property Return the published status for this Agent. queries : Optional [ List [ str ]] property Return the queries for this Agent. query_url : Optional [ str ] property Return the query URL for this Agent. valid : bool property Return whether this Agent is valid. create_agent ( name , description , query_url = None , func_url = None , more_info_url = None , published = None ) Create a new Agent with the given parameters. Source code in fixieai/client/agent.py 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 def create_agent ( self , name : Optional [ str ], description : str , query_url : Optional [ str ] = None , func_url : Optional [ str ] = None , more_info_url : Optional [ str ] = None , published : Optional [ bool ] = None , ) -> str : \"\"\"Create a new Agent with the given parameters.\"\"\" query = gql ( \"\"\" mutation CreateAgent( $handle: String!, $name: String, $description: String!, $queryUrl: String, $funcUrl: String, $moreInfoUrl: String, $published: Boolean) { createAgent( agentData: { handle: $handle, name: $name, description: $description, queryUrl: $queryUrl, funcUrl: $funcUrl, moreInfoUrl: $moreInfoUrl, published: $published } ) { agent { agentId } } } \"\"\" ) variable_values : Dict [ str , Any ] = { \"handle\" : self . _handle } if name is not None : variable_values [ \"name\" ] = name variable_values [ \"description\" ] = description if query_url is not None : variable_values [ \"queryUrl\" ] = query_url if func_url is not None : warnings . warn ( \"Setting func_url via create_agent is deprecated, use FixieClient.create_agent_revision instead.\" ) variable_values [ \"funcUrl\" ] = func_url if more_info_url is not None : variable_values [ \"moreInfoUrl\" ] = more_info_url if published is not None : variable_values [ \"published\" ] = published result = self . _gqlclient . execute ( query , variable_values = variable_values ) if \"createAgent\" not in result or result [ \"createAgent\" ] is None : raise ValueError ( f \"Failed to create Agent\" ) assert isinstance ( result [ \"createAgent\" ], dict ) assert isinstance ( result [ \"createAgent\" ][ \"agent\" ], dict ) assert isinstance ( result [ \"createAgent\" ][ \"agent\" ][ \"agentId\" ], str ) self . _metadata = self . get_metadata () return result [ \"createAgent\" ][ \"agent\" ][ \"agentId\" ] delete_agent () Delete this Agent. Source code in fixieai/client/agent.py 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 def delete_agent ( self ) -> None : \"\"\"Delete this Agent.\"\"\" query = gql ( \"\"\" mutation DeleteAgent($owner: String!, $handle: String!) { deleteAgent(agentData: {owner: $owner, handle: $handle}) { agent { handle } } } \"\"\" ) _ = self . _gqlclient . execute ( query , variable_values = { \"owner\" : self . owner , \"handle\" : self . _handle } ) get_metadata () Return metadata about this Agent. Source code in fixieai/client/agent.py 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 def get_metadata ( self ) -> Dict [ str , Any ]: \"\"\"Return metadata about this Agent.\"\"\" query = gql ( \"\"\" query getAgentById($agentId: String!) { agentById(agentId: $agentId) { agentId handle name description queries moreInfoUrl published owner { __typename ... on UserType { username } ... on OrganizationType { handle } } queryUrl funcUrl created modified } } \"\"\" ) result = self . _gqlclient . execute ( query , variable_values = { \"agentId\" : f \" { self . _owner } / { self . _handle } \" } ) if \"agentById\" not in result or result [ \"agentById\" ] is None : raise ValueError ( f \"Cannot fetch agent metadata for { self . _owner } / { self . _handle } \" ) agent_dict = result [ \"agentById\" ] assert isinstance ( agent_dict , dict ) and all ( isinstance ( k , str ) for k in agent_dict . keys () ) return agent_dict update_agent ( new_handle = None , name = None , description = None , query_url = None , func_url = None , more_info_url = None , published = None ) Update the Agent with the given parameters. Source code in fixieai/client/agent.py 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 def update_agent ( self , new_handle : Optional [ str ] = None , name : Optional [ str ] = None , description : Optional [ str ] = None , query_url : Optional [ str ] = None , func_url : Optional [ str ] = None , more_info_url : Optional [ str ] = None , published : Optional [ bool ] = None , ) -> str : \"\"\"Update the Agent with the given parameters.\"\"\" query = gql ( \"\"\" mutation UpdateAgent( $handle: String!, $newHandle: String, $name: String, $description: String, $queryUrl: String, $funcUrl: String, $moreInfoUrl: String, $published: Boolean) { updateAgent( agentData: { handle: $handle, newHandle: $newHandle, name: $name, description: $description, queryUrl: $queryUrl, funcUrl: $funcUrl, moreInfoUrl: $moreInfoUrl, published: $published } ) { agent { agentId } } } \"\"\" ) variable_values : Dict [ str , Any ] = { \"handle\" : self . _handle } if new_handle is not None : variable_values [ \"newHandle\" ] = new_handle if name is not None : variable_values [ \"name\" ] = name if description is not None : variable_values [ \"description\" ] = description if query_url is not None : variable_values [ \"queryUrl\" ] = query_url if func_url is not None : warnings . warn ( \"Setting func_url via update_agent is deprecated, use FixieClient.create_agent_revision instead.\" ) variable_values [ \"funcUrl\" ] = func_url if more_info_url is not None : variable_values [ \"moreInfoUrl\" ] = more_info_url if published is not None : variable_values [ \"published\" ] = published result = self . _gqlclient . execute ( query , variable_values = variable_values ) if \"updateAgent\" not in result or result [ \"updateAgent\" ] is None : raise ValueError ( f \"Failed to update Agent\" ) assert isinstance ( result [ \"updateAgent\" ], dict ) assert isinstance ( result [ \"updateAgent\" ][ \"agent\" ], dict ) assert isinstance ( result [ \"updateAgent\" ][ \"agent\" ][ \"agentId\" ], str ) self . _metadata = self . get_metadata () if new_handle : self . _handle = new_handle return result [ \"updateAgent\" ][ \"agent\" ][ \"agentId\" ] fixie ( ctx ) Command-line interface to the Fixie platform. Source code in fixieai/cli/cli.py 37 38 39 40 41 @click . group () @click . pass_context def fixie ( ctx ): \"\"\"Command-line interface to the Fixie platform.\"\"\" ctx . ensure_object ( CliContext ) Console A simple console interface for Fixie. Source code in fixieai/cli/session/console.py 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 class Console : \"\"\"A simple console interface for Fixie.\"\"\" def __init__ ( self , client : FixieClient , session : Session , history_file : str = HISTORY_FILE , ): self . _client = client self . _session = session history_file = os . path . expanduser ( history_file ) os . makedirs ( os . path . dirname ( history_file ), exist_ok = True ) self . _history_file = history_file self . _response_index = 0 def run ( self , initial_message : Optional [ str ] = None , ) -> None : \"\"\"Run the console application.\"\"\" textconsole . print ( \"[blue]Welcome to Fixie!\" ) textconsole . print ( f \"Connected to: { self . _session . session_url } \" ) # Show what's already in the session thus far. for message in self . _session . get_messages (): self . _show_message ( message , show_user_message = True ) history = prompt_toolkit . history . FileHistory ( self . _history_file ) if initial_message : prompt_toolkit . print_formatted_text ( f \" { PROMPT }{ initial_message } \" ) history . append_string ( initial_message ) self . _query ( initial_message ) while True : in_text = prompt_toolkit . prompt ( PROMPT , history = history , auto_suggest = prompt_toolkit . auto_suggest . AutoSuggestFromHistory (), ) self . _query ( in_text ) def _query ( self , in_text : str ) -> None : try : self . _response_index += 1 print ( f \" { self . _response_index } \u276f \" , end = \"\" ) pos = 0 sys . stdout . flush () for message in self . _session . streaming_query ( in_text ): text = message [ \"text\" ][ pos :] textconsole . print ( text , end = \"\" ) sys . stdout . flush () pos += len ( text ) print ( \"\" ) self . _show_embeds ( message [ \"text\" ]) except requests . exceptions . HTTPError as e : textconsole . print ( f \"\ud83d\udea8 { e } \" ) return def _show_message ( self , message : Dict [ str , Any ], show_user_message : bool = False ): \"\"\"Shows a message dict from FixieClient. If show_user_message is set, the user messages are also printed with the PROMPT. This option is useful for showing previous messages in the chat when connecting to a session. \"\"\" sender_handle = ( message [ \"sentBy\" ][ \"handle\" ] if message . get ( \"sentBy\" ) else \"<unknown>\" ) message_text = message [ \"text\" ] if message [ \"type\" ] == \"query\" and sender_handle == \"user\" : if show_user_message : textconsole . print ( markdown . Markdown ( PROMPT + message_text )) elif message [ \"type\" ] != \"response\" : textconsole . print ( markdown . Markdown ( f \" @ { sender_handle } : \" + message_text , style = \"dim\" ) ) else : self . _response_index += 1 textconsole . print ( markdown . Markdown ( f \" { self . _response_index } \u276f \" + message_text ) ) self . _show_embeds ( message [ \"text\" ]) def _show_embeds ( self , message : str ): \"\"\"Shows embeds referenced in `message_text`.\"\"\" # Check embed references in message (denoted by #id). embed_ids = _extract_embed_refs ( message ) if not embed_ids : return # Get a dict of all embed_id -> embeds in the session. embeds = { embed_dict [ \"key\" ]: embed_dict [ \"embed\" ] for embed_dict in self . _session . get_embeds () } # Show what we can find. for embed_id in embed_ids : if embed_id not in embeds : textconsole . print ( f \" [dim]embed # { embed_id } not found in session[/]\" , style = \"red\" ) continue _show_embed ( embeds [ embed_id ][ \"url\" ], embeds [ embed_id ][ \"contentType\" ], ) run ( initial_message = None ) Run the console application. Source code in fixieai/cli/session/console.py 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 def run ( self , initial_message : Optional [ str ] = None , ) -> None : \"\"\"Run the console application.\"\"\" textconsole . print ( \"[blue]Welcome to Fixie!\" ) textconsole . print ( f \"Connected to: { self . _session . session_url } \" ) # Show what's already in the session thus far. for message in self . _session . get_messages (): self . _show_message ( message , show_user_message = True ) history = prompt_toolkit . history . FileHistory ( self . _history_file ) if initial_message : prompt_toolkit . print_formatted_text ( f \" { PROMPT }{ initial_message } \" ) history . append_string ( initial_message ) self . _query ( initial_message ) while True : in_text = prompt_toolkit . prompt ( PROMPT , history = history , auto_suggest = prompt_toolkit . auto_suggest . AutoSuggestFromHistory (), ) self . _query ( in_text )","title":"Python Client API"},{"location":"python-client-api/#fixie-client-python-api-reference","text":"","title":"Fixie Client Python API Reference"},{"location":"python-client-api/#fixieai.client.client.FixieClient","text":"FixieClient is a client to the Fixie system. Parameters: api_key ( Optional [ str ] ) \u2013 The API key for the Fixie API server. If not provided, the FIXIE_API_KEY environment variable will be used. If that is not set, the authenticated user API key will be used, or a ValueError will be raised if the user is not authenticated. Source code in fixieai/client/client.py 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 class FixieClient : \"\"\"FixieClient is a client to the Fixie system. Args: api_key: The API key for the Fixie API server. If not provided, the FIXIE_API_KEY environment variable will be used. If that is not set, the authenticated user API key will be used, or a ValueError will be raised if the user is not authenticated. \"\"\" def __init__ ( self , api_key : Optional [ str ] = None , ): self . _api_key = api_key or constants . fixie_api_key () logging . info ( f \"Using Fixie API URL: { constants . FIXIE_API_URL } \" ) self . _request_headers = { \"Authorization\" : f \"Bearer { self . _api_key } \" } transport = RequestsHTTPTransport ( url = constants . FIXIE_GRAPHQL_URL , headers = self . _request_headers , ) self . _rest_client = requests . Session () self . _gqlclient = Client ( transport = transport , fetch_schema_from_transport = False ) @property def gqlclient ( self ) -> Client : \"\"\"Return the underlying GraphQL client used by this FixieClient.\"\"\" return self . _gqlclient @property def url ( self ) -> str : \"\"\"Return the URL of the Fixie API server.\"\"\" return constants . FIXIE_API_URL def get_agents ( self ) -> Dict [ str , Dict [ str , str ]]: \"\"\"Return metadata about all running Fixie Agents. The keys of the returned dictionary are the Agent handles, and the values are dictionaries containing metadata about each Agent.\"\"\" query = gql ( \"\"\" query getAgents { allAgents { agentId name description moreInfoUrl } } \"\"\" ) result = self . _gqlclient . execute ( query ) assert \"allAgents\" in result and isinstance ( result [ \"allAgents\" ], list ) agents = result [ \"allAgents\" ] return { agent [ \"agentId\" ]: agent for agent in agents } def get_agent ( self , agent_id : str ) -> Agent : \"\"\"Return an existing Agent object.\"\"\" return Agent ( self , agent_id ) def get_agent_page_url ( self , agent_id : str ) -> str : \"\"\"Return the URL of the Agent page on the Fixie Platform.\"\"\" return f \" { constants . FIXIE_WEB_AGENT_URL } / { agent_id } \" def create_agent ( self , handle : str , name : str , description : str , query_url : Optional [ str ] = None , func_url : Optional [ str ] = None , more_info_url : Optional [ str ] = None , published : Optional [ bool ] = None , ) -> Agent : \"\"\"Create a new Agent. Args: handle: The handle for the new Agent. This must be unique across all Agents owned by this user. name: The name of the new Agent. description: A description of the new Agent. query_url: (deprecated) Unused. func_url: (deprecated) The URL of the new Agent's func endpoint. more_info_url: A URL with more information about the new Agent. published: Whether the new Agent should be published. \"\"\" agent = Agent ( self , f \" { self . get_current_username () } / { handle } \" ) agent . create_agent ( name , description , query_url , func_url , more_info_url , published ) return agent def get_sessions ( self ) -> List [ str ]: \"\"\"Return a list of all session IDs.\"\"\" query = gql ( \"\"\" query getSessions { allSessions { handle } } \"\"\" ) result = self . _gqlclient . execute ( query ) assert \"allSessions\" in result and isinstance ( result [ \"allSessions\" ], list ) sessions = result [ \"allSessions\" ] return [ session [ \"handle\" ] for session in sessions ] def create_session ( self , frontend_agent_id : Optional [ str ] = None ) -> Session : \"\"\"Create a new Session.\"\"\" return Session ( self , frontend_agent_id = frontend_agent_id ) def get_session ( self , session_id : str ) -> Session : \"\"\"Return an existing Session object.\"\"\" return Session ( self , session_id ) def get_current_user ( self ) -> Dict [ str , Any ]: \"\"\"Returns the user metadata of the current user.\"\"\" query = gql ( \"\"\" query getUsername { user { username firstName lastName email organization { handle name } dailyQueryLimit dailyUsedQueries avatar } } \"\"\" ) result = self . _gqlclient . execute ( query ) assert \"user\" in result and isinstance ( result [ \"user\" ], dict ) return result [ \"user\" ] def get_current_username ( self ) -> str : \"\"\"Returns the username of the current user.\"\"\" user = self . get_current_user () assert \"username\" in user and isinstance ( user [ \"username\" ], str ) return user [ \"username\" ] def refresh_agent ( self , agent_handle : str ): \"\"\"Indicates that an agent's prompts should be refreshed.\"\"\" username = self . get_current_username () self . post ( f \" { constants . FIXIE_REFRESH_URL } / { username } / { agent_handle } \" ) def create_agent_revision ( self , handle : str , make_current : bool , * , reindex_corpora : bool = False , metadata : Optional [ Dict [ str , str ]] = None , external_url : Optional [ str ] = None , gzip_tarfile : Optional [ BinaryIO ] = None , environment : FixieEnvironment = FixieEnvironment . PYTHON , ) -> str : \"\"\"Creates a new Agent revision. Args: handle: The handle of the Agent. Must be owned by the current user. make_current: Whether the new revision should be made the current (active) revision. reindex_corpora: Whether to reindex all corpora for the new revision. metadata: Optional client-provided metadata to associate with the revision. external_url: The URL at which the revision is hosted, if hosted externally. gzip_tarfile: A file-like of a gzip-compressed tarfile containing the files to deploy. environment: The environment in which the revision should be run. Exactly one of `external_url` and `gzip_tarfile` must be provided. \"\"\" mutation = gql ( \"\"\" mutation CreateAgentRevision( $handle: String!, $metadata: [RevisionMetadataKeyValuePairInput!]!, $makeCurrent: Boolean!, $externalDeployment: ExternalDeploymentInput, $managedDeployment: ManagedDeploymentInput, $reindexCorpora: Boolean!, ) { createAgentRevision(agentHandle: $handle, makeCurrent: $makeCurrent, revision: { metadata: $metadata externalDeployment: $externalDeployment managedDeployment: $managedDeployment }, reindexCorpora: $reindexCorpora) { revision { id } } } \"\"\" ) with utils . patched_gql_file_uploader ( gzip_tarfile , \"upload.tar.gz\" , \"application/gzip\" ): result = self . _gqlclient . execute ( mutation , variable_values = { \"handle\" : handle , \"metadata\" : [ { \"key\" : key , \"value\" : value } for key , value in metadata . items () ] if metadata else [], \"makeCurrent\" : make_current , \"reindexCorpora\" : reindex_corpora , \"externalDeployment\" : { \"url\" : external_url } if external_url else None , \"managedDeployment\" : { \"environment\" : environment , \"codePackage\" : gzip_tarfile , } if gzip_tarfile else None , }, upload_files = True , ) revision_id = result [ \"createAgentRevision\" ][ \"revision\" ][ \"id\" ] assert isinstance ( revision_id , str ) return revision_id def get_current_agent_revision ( self , handle : str ) -> Optional [ str ]: \"\"\"Gets the current (active) revision of an agent.\"\"\" agent = self . get_agent ( handle ) query = gql ( \"\"\" query GetRevisionId($agentId: String!) { agentById(agentId: $agentId) { currentRevision { id } } } \"\"\" ) response = self . _gqlclient . execute ( query , variable_values = { \"agentId\" : agent . agent_id }, ) revision = response [ \"agentById\" ][ \"currentRevision\" ] return revision [ \"id\" ] if revision is not None else None def set_current_agent_revision ( self , handle : str , revision_id : str ): \"\"\"Sets the current (active) revision of an agent.\"\"\" mutation = gql ( \"\"\" mutation SetCurrentAgentRevision( $handle: String!, $currentRevisionId: ID!) { updateAgent( agentData: { handle: $handle, currentRevisionId: $currentRevisionId } ) { agent { agentId } } } \"\"\" ) _ = self . _gqlclient . execute ( mutation , variable_values = { \"handle\" : handle , \"currentRevisionId\" : revision_id }, ) def delete_agent_revision ( self , handle : str , revision_id : str ): \"\"\"Deletes an Agent revision.\"\"\" mutation = gql ( \"\"\" mutation DeleteRevision($handle: String!, $revisionId: ID!) { deleteAgentRevision(agentHandle: $handle, revisionId: $revisionId) { agent { agentId } } } \"\"\" ) _ = self . _gqlclient . execute ( mutation , variable_values = { \"handle\" : handle , \"revisionId\" : revision_id } ) def deploy_agent ( self , handle : str , gzip_tarfile : BinaryIO , environment : FixieEnvironment ): \"\"\"Deploys an agent implementation. Args: handle: The handle of the Agent to deploy. Must be owned by the current user. gzip_tarfile: A file-like of a gzip-compressed tarfile containing the files to deploy. \"\"\" return self . create_agent_revision ( handle , make_current = True , gzip_tarfile = gzip_tarfile , environment = environment , ) def post ( self , url : str , data : Optional [ Dict [ str , Any ]] = None ) -> Any : \"\"\"Performs a POST request with the appropriate auth token. The response will be parsed as JSON and returned. Args: url: The URL to POST to, which should start with https://api.fixie.ai/api data: The data to send in the request body (optional) \"\"\" assert url . startswith ( constants . FIXIE_API_URL ) response = self . _rest_client . post ( url , headers = self . _request_headers , json = data ) response . raise_for_status () return response . json () def streaming_post ( self , url : str , data : Optional [ Dict [ str , Any ]] = None ) -> Generator [ Any , None , None ]: \"\"\"Performs a POST request with the appropriate auth token, and handles a streaming response. The response will be yielded as a generator of JSON objects, one per line. Args: url: The URL to POST to, which should start with https://api.fixie.ai/api data: The data to send in the request body (optional) \"\"\" assert url . startswith ( constants . FIXIE_API_URL ) response = self . _rest_client . post ( url , headers = self . _request_headers , json = data , stream = True ) response . raise_for_status () return ( json . loads ( line ) for line in response . iter_lines () if line )","title":"FixieClient"},{"location":"python-client-api/#fixieai.client.client.FixieClient.gqlclient","text":"Return the underlying GraphQL client used by this FixieClient.","title":"gqlclient"},{"location":"python-client-api/#fixieai.client.client.FixieClient.url","text":"Return the URL of the Fixie API server.","title":"url"},{"location":"python-client-api/#fixieai.client.client.FixieClient.create_agent","text":"Create a new Agent. Parameters: handle ( str ) \u2013 The handle for the new Agent. This must be unique across all Agents owned by this user. name ( str ) \u2013 The name of the new Agent. description ( str ) \u2013 A description of the new Agent. query_url ( Optional [ str ] ) \u2013 (deprecated) Unused. func_url ( Optional [ str ] ) \u2013 (deprecated) The URL of the new Agent's func endpoint. more_info_url ( Optional [ str ] ) \u2013 A URL with more information about the new Agent. published ( Optional [ bool ] ) \u2013 Whether the new Agent should be published. Source code in fixieai/client/client.py 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 def create_agent ( self , handle : str , name : str , description : str , query_url : Optional [ str ] = None , func_url : Optional [ str ] = None , more_info_url : Optional [ str ] = None , published : Optional [ bool ] = None , ) -> Agent : \"\"\"Create a new Agent. Args: handle: The handle for the new Agent. This must be unique across all Agents owned by this user. name: The name of the new Agent. description: A description of the new Agent. query_url: (deprecated) Unused. func_url: (deprecated) The URL of the new Agent's func endpoint. more_info_url: A URL with more information about the new Agent. published: Whether the new Agent should be published. \"\"\" agent = Agent ( self , f \" { self . get_current_username () } / { handle } \" ) agent . create_agent ( name , description , query_url , func_url , more_info_url , published ) return agent","title":"create_agent()"},{"location":"python-client-api/#fixieai.client.client.FixieClient.create_agent_revision","text":"Creates a new Agent revision. Parameters: handle ( str ) \u2013 The handle of the Agent. Must be owned by the current user. make_current ( bool ) \u2013 Whether the new revision should be made the current (active) revision. reindex_corpora ( bool ) \u2013 Whether to reindex all corpora for the new revision. metadata ( Optional [ Dict [ str , str ]] ) \u2013 Optional client-provided metadata to associate with the revision. external_url ( Optional [ str ] ) \u2013 The URL at which the revision is hosted, if hosted externally. gzip_tarfile ( Optional [ BinaryIO ] ) \u2013 A file-like of a gzip-compressed tarfile containing the files to deploy. environment ( FixieEnvironment ) \u2013 The environment in which the revision should be run. Exactly one of external_url and gzip_tarfile must be provided. Source code in fixieai/client/client.py 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 def create_agent_revision ( self , handle : str , make_current : bool , * , reindex_corpora : bool = False , metadata : Optional [ Dict [ str , str ]] = None , external_url : Optional [ str ] = None , gzip_tarfile : Optional [ BinaryIO ] = None , environment : FixieEnvironment = FixieEnvironment . PYTHON , ) -> str : \"\"\"Creates a new Agent revision. Args: handle: The handle of the Agent. Must be owned by the current user. make_current: Whether the new revision should be made the current (active) revision. reindex_corpora: Whether to reindex all corpora for the new revision. metadata: Optional client-provided metadata to associate with the revision. external_url: The URL at which the revision is hosted, if hosted externally. gzip_tarfile: A file-like of a gzip-compressed tarfile containing the files to deploy. environment: The environment in which the revision should be run. Exactly one of `external_url` and `gzip_tarfile` must be provided. \"\"\" mutation = gql ( \"\"\" mutation CreateAgentRevision( $handle: String!, $metadata: [RevisionMetadataKeyValuePairInput!]!, $makeCurrent: Boolean!, $externalDeployment: ExternalDeploymentInput, $managedDeployment: ManagedDeploymentInput, $reindexCorpora: Boolean!, ) { createAgentRevision(agentHandle: $handle, makeCurrent: $makeCurrent, revision: { metadata: $metadata externalDeployment: $externalDeployment managedDeployment: $managedDeployment }, reindexCorpora: $reindexCorpora) { revision { id } } } \"\"\" ) with utils . patched_gql_file_uploader ( gzip_tarfile , \"upload.tar.gz\" , \"application/gzip\" ): result = self . _gqlclient . execute ( mutation , variable_values = { \"handle\" : handle , \"metadata\" : [ { \"key\" : key , \"value\" : value } for key , value in metadata . items () ] if metadata else [], \"makeCurrent\" : make_current , \"reindexCorpora\" : reindex_corpora , \"externalDeployment\" : { \"url\" : external_url } if external_url else None , \"managedDeployment\" : { \"environment\" : environment , \"codePackage\" : gzip_tarfile , } if gzip_tarfile else None , }, upload_files = True , ) revision_id = result [ \"createAgentRevision\" ][ \"revision\" ][ \"id\" ] assert isinstance ( revision_id , str ) return revision_id","title":"create_agent_revision()"},{"location":"python-client-api/#fixieai.client.client.FixieClient.create_session","text":"Create a new Session. Source code in fixieai/client/client.py 174 175 176 def create_session ( self , frontend_agent_id : Optional [ str ] = None ) -> Session : \"\"\"Create a new Session.\"\"\" return Session ( self , frontend_agent_id = frontend_agent_id )","title":"create_session()"},{"location":"python-client-api/#fixieai.client.client.FixieClient.delete_agent_revision","text":"Deletes an Agent revision. Source code in fixieai/client/client.py 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 def delete_agent_revision ( self , handle : str , revision_id : str ): \"\"\"Deletes an Agent revision.\"\"\" mutation = gql ( \"\"\" mutation DeleteRevision($handle: String!, $revisionId: ID!) { deleteAgentRevision(agentHandle: $handle, revisionId: $revisionId) { agent { agentId } } } \"\"\" ) _ = self . _gqlclient . execute ( mutation , variable_values = { \"handle\" : handle , \"revisionId\" : revision_id } )","title":"delete_agent_revision()"},{"location":"python-client-api/#fixieai.client.client.FixieClient.deploy_agent","text":"Deploys an agent implementation. Parameters: handle ( str ) \u2013 The handle of the Agent to deploy. Must be owned by the current user. gzip_tarfile ( BinaryIO ) \u2013 A file-like of a gzip-compressed tarfile containing the files to deploy. Source code in fixieai/client/client.py 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 def deploy_agent ( self , handle : str , gzip_tarfile : BinaryIO , environment : FixieEnvironment ): \"\"\"Deploys an agent implementation. Args: handle: The handle of the Agent to deploy. Must be owned by the current user. gzip_tarfile: A file-like of a gzip-compressed tarfile containing the files to deploy. \"\"\" return self . create_agent_revision ( handle , make_current = True , gzip_tarfile = gzip_tarfile , environment = environment , )","title":"deploy_agent()"},{"location":"python-client-api/#fixieai.client.client.FixieClient.get_agent","text":"Return an existing Agent object. Source code in fixieai/client/client.py 121 122 123 def get_agent ( self , agent_id : str ) -> Agent : \"\"\"Return an existing Agent object.\"\"\" return Agent ( self , agent_id )","title":"get_agent()"},{"location":"python-client-api/#fixieai.client.client.FixieClient.get_agent_page_url","text":"Return the URL of the Agent page on the Fixie Platform. Source code in fixieai/client/client.py 125 126 127 def get_agent_page_url ( self , agent_id : str ) -> str : \"\"\"Return the URL of the Agent page on the Fixie Platform.\"\"\" return f \" { constants . FIXIE_WEB_AGENT_URL } / { agent_id } \"","title":"get_agent_page_url()"},{"location":"python-client-api/#fixieai.client.client.FixieClient.get_agents","text":"Return metadata about all running Fixie Agents. The keys of the returned dictionary are the Agent handles, and the values are dictionaries containing metadata about each Agent. Source code in fixieai/client/client.py 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 def get_agents ( self ) -> Dict [ str , Dict [ str , str ]]: \"\"\"Return metadata about all running Fixie Agents. The keys of the returned dictionary are the Agent handles, and the values are dictionaries containing metadata about each Agent.\"\"\" query = gql ( \"\"\" query getAgents { allAgents { agentId name description moreInfoUrl } } \"\"\" ) result = self . _gqlclient . execute ( query ) assert \"allAgents\" in result and isinstance ( result [ \"allAgents\" ], list ) agents = result [ \"allAgents\" ] return { agent [ \"agentId\" ]: agent for agent in agents }","title":"get_agents()"},{"location":"python-client-api/#fixieai.client.client.FixieClient.get_current_agent_revision","text":"Gets the current (active) revision of an agent. Source code in fixieai/client/client.py 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 def get_current_agent_revision ( self , handle : str ) -> Optional [ str ]: \"\"\"Gets the current (active) revision of an agent.\"\"\" agent = self . get_agent ( handle ) query = gql ( \"\"\" query GetRevisionId($agentId: String!) { agentById(agentId: $agentId) { currentRevision { id } } } \"\"\" ) response = self . _gqlclient . execute ( query , variable_values = { \"agentId\" : agent . agent_id }, ) revision = response [ \"agentById\" ][ \"currentRevision\" ] return revision [ \"id\" ] if revision is not None else None","title":"get_current_agent_revision()"},{"location":"python-client-api/#fixieai.client.client.FixieClient.get_current_user","text":"Returns the user metadata of the current user. Source code in fixieai/client/client.py 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 def get_current_user ( self ) -> Dict [ str , Any ]: \"\"\"Returns the user metadata of the current user.\"\"\" query = gql ( \"\"\" query getUsername { user { username firstName lastName email organization { handle name } dailyQueryLimit dailyUsedQueries avatar } } \"\"\" ) result = self . _gqlclient . execute ( query ) assert \"user\" in result and isinstance ( result [ \"user\" ], dict ) return result [ \"user\" ]","title":"get_current_user()"},{"location":"python-client-api/#fixieai.client.client.FixieClient.get_current_username","text":"Returns the username of the current user. Source code in fixieai/client/client.py 207 208 209 210 211 def get_current_username ( self ) -> str : \"\"\"Returns the username of the current user.\"\"\" user = self . get_current_user () assert \"username\" in user and isinstance ( user [ \"username\" ], str ) return user [ \"username\" ]","title":"get_current_username()"},{"location":"python-client-api/#fixieai.client.client.FixieClient.get_session","text":"Return an existing Session object. Source code in fixieai/client/client.py 178 179 180 def get_session ( self , session_id : str ) -> Session : \"\"\"Return an existing Session object.\"\"\" return Session ( self , session_id )","title":"get_session()"},{"location":"python-client-api/#fixieai.client.client.FixieClient.get_sessions","text":"Return a list of all session IDs. Source code in fixieai/client/client.py 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 def get_sessions ( self ) -> List [ str ]: \"\"\"Return a list of all session IDs.\"\"\" query = gql ( \"\"\" query getSessions { allSessions { handle } } \"\"\" ) result = self . _gqlclient . execute ( query ) assert \"allSessions\" in result and isinstance ( result [ \"allSessions\" ], list ) sessions = result [ \"allSessions\" ] return [ session [ \"handle\" ] for session in sessions ]","title":"get_sessions()"},{"location":"python-client-api/#fixieai.client.client.FixieClient.post","text":"Performs a POST request with the appropriate auth token. The response will be parsed as JSON and returned. Parameters: url ( str ) \u2013 The URL to POST to, which should start with https://api.fixie.ai/api data ( Optional [ Dict [ str , Any ]] ) \u2013 The data to send in the request body (optional) Source code in fixieai/client/client.py 381 382 383 384 385 386 387 388 389 390 391 392 def post ( self , url : str , data : Optional [ Dict [ str , Any ]] = None ) -> Any : \"\"\"Performs a POST request with the appropriate auth token. The response will be parsed as JSON and returned. Args: url: The URL to POST to, which should start with https://api.fixie.ai/api data: The data to send in the request body (optional) \"\"\" assert url . startswith ( constants . FIXIE_API_URL ) response = self . _rest_client . post ( url , headers = self . _request_headers , json = data ) response . raise_for_status () return response . json ()","title":"post()"},{"location":"python-client-api/#fixieai.client.client.FixieClient.refresh_agent","text":"Indicates that an agent's prompts should be refreshed. Source code in fixieai/client/client.py 213 214 215 216 def refresh_agent ( self , agent_handle : str ): \"\"\"Indicates that an agent's prompts should be refreshed.\"\"\" username = self . get_current_username () self . post ( f \" { constants . FIXIE_REFRESH_URL } / { username } / { agent_handle } \" )","title":"refresh_agent()"},{"location":"python-client-api/#fixieai.client.client.FixieClient.set_current_agent_revision","text":"Sets the current (active) revision of an agent. Source code in fixieai/client/client.py 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 def set_current_agent_revision ( self , handle : str , revision_id : str ): \"\"\"Sets the current (active) revision of an agent.\"\"\" mutation = gql ( \"\"\" mutation SetCurrentAgentRevision( $handle: String!, $currentRevisionId: ID!) { updateAgent( agentData: { handle: $handle, currentRevisionId: $currentRevisionId } ) { agent { agentId } } } \"\"\" ) _ = self . _gqlclient . execute ( mutation , variable_values = { \"handle\" : handle , \"currentRevisionId\" : revision_id }, )","title":"set_current_agent_revision()"},{"location":"python-client-api/#fixieai.client.client.FixieClient.streaming_post","text":"Performs a POST request with the appropriate auth token, and handles a streaming response. The response will be yielded as a generator of JSON objects, one per line. Parameters: url ( str ) \u2013 The URL to POST to, which should start with https://api.fixie.ai/api data ( Optional [ Dict [ str , Any ]] ) \u2013 The data to send in the request body (optional) Source code in fixieai/client/client.py 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 def streaming_post ( self , url : str , data : Optional [ Dict [ str , Any ]] = None ) -> Generator [ Any , None , None ]: \"\"\"Performs a POST request with the appropriate auth token, and handles a streaming response. The response will be yielded as a generator of JSON objects, one per line. Args: url: The URL to POST to, which should start with https://api.fixie.ai/api data: The data to send in the request body (optional) \"\"\" assert url . startswith ( constants . FIXIE_API_URL ) response = self . _rest_client . post ( url , headers = self . _request_headers , json = data , stream = True ) response . raise_for_status () return ( json . loads ( line ) for line in response . iter_lines () if line )","title":"streaming_post()"},{"location":"python-client-api/#fixieai.client.client.get_agents","text":"Return metadata about all Fixie Agents. The keys of the returned dictionary are Agent IDs, and the values are dictionaries containing metadata about each Agent. Source code in fixieai/client/client.py 48 49 50 51 52 def get_agents () -> Dict [ str , Dict [ str , str ]]: \"\"\"Return metadata about all Fixie Agents. The keys of the returned dictionary are Agent IDs, and the values are dictionaries containing metadata about each Agent.\"\"\" return get_client () . get_agents ()","title":"get_agents()"},{"location":"python-client-api/#fixieai.client.client.get_client","text":"Return the global FixieClient instance. Source code in fixieai/client/client.py 30 31 32 33 34 35 36 def get_client () -> FixieClient : \"\"\"Return the global FixieClient instance.\"\"\" global _CLIENT if not _CLIENT : _CLIENT = FixieClient () assert _CLIENT is not None return _CLIENT","title":"get_client()"},{"location":"python-client-api/#fixieai.client.client.get_embeds","text":"Return a list of Embeds. Source code in fixieai/client/client.py 60 61 62 def get_embeds () -> List [ Dict [ str , Any ]]: \"\"\"Return a list of Embeds.\"\"\" return get_session () . get_embeds ()","title":"get_embeds()"},{"location":"python-client-api/#fixieai.client.client.get_session","text":"Return the global Fixie Session instance. Source code in fixieai/client/client.py 39 40 41 42 43 44 45 def get_session () -> Session : \"\"\"Return the global Fixie Session instance.\"\"\" global _SESSION if not _SESSION : _SESSION = Session ( get_client ()) assert _SESSION is not None return _SESSION","title":"get_session()"},{"location":"python-client-api/#fixieai.client.client.query","text":"Run a query. Source code in fixieai/client/client.py 55 56 57 def query ( text : str ) -> str : \"\"\"Run a query.\"\"\" return get_session () . query ( text )","title":"query()"},{"location":"python-client-api/#fixieai.client.session.Session","text":"Represents a single session with the Fixie system. Parameters: client ( FixieClient ) \u2013 The FixieClient instance to use. session_id ( Optional [ str ] ) \u2013 The ID of the session to use. If not provided, a new session will be created. Source code in fixieai/client/session.py 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 class Session : \"\"\"Represents a single session with the Fixie system. Args: client: The FixieClient instance to use. session_id: The ID of the session to use. If not provided, a new session will be created. \"\"\" def __init__ ( self , client : FixieClient , session_id : Optional [ str ] = None , frontend_agent_id : Optional [ str ] = None , ): self . _client = client self . _gqlclient = self . _client . gqlclient self . _session_id = session_id self . _frontend_agent_id = frontend_agent_id if session_id : # Test that the session exists. _ = self . get_metadata () assert ( frontend_agent_id is None ), \"Cannot specify frontend_agent_id when using an existing session\" else : self . _session_id = self . _create_session ( frontend_agent_id ) @property def session_id ( self ) -> Optional [ str ]: \"\"\"Return the session ID used by this Fixie client.\"\"\" return self . _session_id @property def session_url ( self ) -> str : \"\"\"Return the URL of the Fixie session.\"\"\" return f \" { self . _client . url } /sessions/ { self . session_id } \" @property def frontend_agent_id ( self ) -> Optional [ str ]: \"\"\"Return the frontend agent ID used by this Fixie client.\"\"\" return self . _frontend_agent_id def _create_session ( self , frontend_agent_id : Optional [ str ] = None ) -> str : \"\"\"Create a new session.\"\"\" assert self . _session_id is None query = gql ( \"\"\" mutation CreateSession($frontendAgentId: String) { createSession(sessionData: {frontendAgentId: $frontendAgentId}) { session { handle frontendAgentId } } } \"\"\" ) result = self . _gqlclient . execute ( query , variable_values = { \"frontendAgentId\" : frontend_agent_id } ) if \"createSession\" not in result or result [ \"createSession\" ] is None : raise ValueError ( f \"Failed to create Session\" ) assert isinstance ( result [ \"createSession\" ], dict ) assert isinstance ( result [ \"createSession\" ][ \"session\" ], dict ) assert isinstance ( result [ \"createSession\" ][ \"session\" ][ \"handle\" ], str ) return result [ \"createSession\" ][ \"session\" ][ \"handle\" ] def get_metadata ( self ) -> Dict [ str , Any ]: \"\"\"Return metadata about this session.\"\"\" query = gql ( \"\"\" query getSession($session_id: String!) { sessionByHandle(handle: $session_id) { handle name description frontendAgentId } } \"\"\" ) result = self . _gqlclient . execute ( query , variable_values = { \"session_id\" : self . _session_id } ) assert \"sessionByHandle\" in result and isinstance ( result [ \"sessionByHandle\" ], dict ) self . _frontend_agent_id = result [ \"sessionByHandle\" ][ \"frontendAgentId\" ] return result [ \"sessionByHandle\" ] def delete_session ( self ) -> None : \"\"\"Delete the current session.\"\"\" query = gql ( \"\"\" mutation DeleteSession($handle: String!) { deleteSession(handle: $handle) { session { handle } } } \"\"\" ) _ = self . _gqlclient . execute ( query , variable_values = { \"handle\" : self . _session_id }) def get_embeds ( self ) -> List [ Dict [ str , Any ]]: \"\"\"Return the Embeds attached to this Session.\"\"\" query = gql ( \"\"\" query getEmbeds($handle: String!) { sessionByHandle(handle: $handle) { embeds { key embed { id contentType created contentHash owner { username } url } } } } \"\"\" ) result = self . _gqlclient . execute ( query , variable_values = { \"handle\" : self . _session_id } ) assert ( \"sessionByHandle\" in result and isinstance ( result [ \"sessionByHandle\" ], dict ) and isinstance ( result [ \"sessionByHandle\" ][ \"embeds\" ], list ) ) return result [ \"sessionByHandle\" ][ \"embeds\" ] def get_messages ( self ) -> List [ Dict [ str , Any ]]: \"\"\"Return the messages that make up this session.\"\"\" query = gql ( \"\"\" query getMessages($handle: String!) { sessionByHandle(handle: $handle) { messages { id text sentBy { handle } type inReplyTo { id } timestamp } } } \"\"\" ) result = self . _gqlclient . execute ( query , variable_values = { \"handle\" : self . _session_id } ) assert ( \"sessionByHandle\" in result and isinstance ( result [ \"sessionByHandle\" ], dict ) and isinstance ( result [ \"sessionByHandle\" ][ \"messages\" ], list ) ) return result [ \"sessionByHandle\" ][ \"messages\" ] def query ( self , text : str ) -> str : \"\"\"Run a single query against the Fixie API and return the response.\"\"\" final = \"\" for message in self . streaming_query ( text ): final = message [ \"text\" ] return final def streaming_query ( self , text : str ) -> Generator [ Dict [ str , Any ], None , None ]: \"\"\"Run a single query against the Fixie API and return a stream.\"\"\" data = { \"session\" : self . _session_id , \"message\" : { \"text\" : text }, \"stream\" : True , } url = f \" { constants . FIXIE_AGENT_URL } / { self . _frontend_agent_id } \" for response in self . _client . streaming_post ( url , data ): yield { \"text\" : response [ \"message\" ][ \"text\" ], \"type\" : response [ \"type\" ], }","title":"Session"},{"location":"python-client-api/#fixieai.client.session.Session.frontend_agent_id","text":"Return the frontend agent ID used by this Fixie client.","title":"frontend_agent_id"},{"location":"python-client-api/#fixieai.client.session.Session.session_id","text":"Return the session ID used by this Fixie client.","title":"session_id"},{"location":"python-client-api/#fixieai.client.session.Session.session_url","text":"Return the URL of the Fixie session.","title":"session_url"},{"location":"python-client-api/#fixieai.client.session.Session.delete_session","text":"Delete the current session. Source code in fixieai/client/session.py 113 114 115 116 117 118 119 120 121 122 123 124 125 126 def delete_session ( self ) -> None : \"\"\"Delete the current session.\"\"\" query = gql ( \"\"\" mutation DeleteSession($handle: String!) { deleteSession(handle: $handle) { session { handle } } } \"\"\" ) _ = self . _gqlclient . execute ( query , variable_values = { \"handle\" : self . _session_id })","title":"delete_session()"},{"location":"python-client-api/#fixieai.client.session.Session.get_embeds","text":"Return the Embeds attached to this Session. Source code in fixieai/client/session.py 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 def get_embeds ( self ) -> List [ Dict [ str , Any ]]: \"\"\"Return the Embeds attached to this Session.\"\"\" query = gql ( \"\"\" query getEmbeds($handle: String!) { sessionByHandle(handle: $handle) { embeds { key embed { id contentType created contentHash owner { username } url } } } } \"\"\" ) result = self . _gqlclient . execute ( query , variable_values = { \"handle\" : self . _session_id } ) assert ( \"sessionByHandle\" in result and isinstance ( result [ \"sessionByHandle\" ], dict ) and isinstance ( result [ \"sessionByHandle\" ][ \"embeds\" ], list ) ) return result [ \"sessionByHandle\" ][ \"embeds\" ]","title":"get_embeds()"},{"location":"python-client-api/#fixieai.client.session.Session.get_messages","text":"Return the messages that make up this session. Source code in fixieai/client/session.py 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 def get_messages ( self ) -> List [ Dict [ str , Any ]]: \"\"\"Return the messages that make up this session.\"\"\" query = gql ( \"\"\" query getMessages($handle: String!) { sessionByHandle(handle: $handle) { messages { id text sentBy { handle } type inReplyTo { id } timestamp } } } \"\"\" ) result = self . _gqlclient . execute ( query , variable_values = { \"handle\" : self . _session_id } ) assert ( \"sessionByHandle\" in result and isinstance ( result [ \"sessionByHandle\" ], dict ) and isinstance ( result [ \"sessionByHandle\" ][ \"messages\" ], list ) ) return result [ \"sessionByHandle\" ][ \"messages\" ]","title":"get_messages()"},{"location":"python-client-api/#fixieai.client.session.Session.get_metadata","text":"Return metadata about this session. Source code in fixieai/client/session.py 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 def get_metadata ( self ) -> Dict [ str , Any ]: \"\"\"Return metadata about this session.\"\"\" query = gql ( \"\"\" query getSession($session_id: String!) { sessionByHandle(handle: $session_id) { handle name description frontendAgentId } } \"\"\" ) result = self . _gqlclient . execute ( query , variable_values = { \"session_id\" : self . _session_id } ) assert \"sessionByHandle\" in result and isinstance ( result [ \"sessionByHandle\" ], dict ) self . _frontend_agent_id = result [ \"sessionByHandle\" ][ \"frontendAgentId\" ] return result [ \"sessionByHandle\" ]","title":"get_metadata()"},{"location":"python-client-api/#fixieai.client.session.Session.query","text":"Run a single query against the Fixie API and return the response. Source code in fixieai/client/session.py 191 192 193 194 195 196 def query ( self , text : str ) -> str : \"\"\"Run a single query against the Fixie API and return the response.\"\"\" final = \"\" for message in self . streaming_query ( text ): final = message [ \"text\" ] return final","title":"query()"},{"location":"python-client-api/#fixieai.client.session.Session.streaming_query","text":"Run a single query against the Fixie API and return a stream. Source code in fixieai/client/session.py 198 199 200 201 202 203 204 205 206 207 208 209 210 def streaming_query ( self , text : str ) -> Generator [ Dict [ str , Any ], None , None ]: \"\"\"Run a single query against the Fixie API and return a stream.\"\"\" data = { \"session\" : self . _session_id , \"message\" : { \"text\" : text }, \"stream\" : True , } url = f \" { constants . FIXIE_AGENT_URL } / { self . _frontend_agent_id } \" for response in self . _client . streaming_post ( url , data ): yield { \"text\" : response [ \"message\" ][ \"text\" ], \"type\" : response [ \"type\" ], }","title":"streaming_query()"},{"location":"python-client-api/#fixieai.client.agent.Agent","text":"Provides an interface to the Fixie GraphQL Agent API. Parameters: client ( FixieClient ) \u2013 The FixieClient instance to use. agent_id ( str ) \u2013 The Agent ID, e.g., \"fixie/calc\", or handle, e.g., \"dice\". Source code in fixieai/client/agent.py 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 class Agent : \"\"\"Provides an interface to the Fixie GraphQL Agent API. Args: client: The FixieClient instance to use. agent_id: The Agent ID, e.g., \"fixie/calc\", or handle, e.g., \"dice\". \"\"\" def __init__ ( self , client : FixieClient , agent_id : str , ): self . _client = client self . _gqlclient = self . _client . gqlclient self . _agent_id = agent_id self . _owner : Optional [ str ] = None if \"/\" in agent_id : self . _owner , self . _handle = agent_id . split ( \"/\" ) else : self . _owner = self . _client . get_current_username () self . _handle = agent_id self . _metadata : Optional [ Dict [ str , Any ]] = None try : self . _metadata = self . get_metadata () except : self . _metadata = None @property def agent_id ( self ) -> str : \"\"\"Return the agentId for this Agent.\"\"\" return self . _agent_id @property def handle ( self ) -> str : \"\"\"Return the handle for this Agent.\"\"\" return self . _handle @property def valid ( self ) -> bool : \"\"\"Return whether this Agent is valid.\"\"\" return self . _metadata is not None @property def name ( self ) -> Optional [ str ]: \"\"\"Return the name for this Agent.\"\"\" if self . _metadata is None : return None name = self . _metadata [ \"name\" ] assert name is None or isinstance ( name , str ) return name @property def description ( self ) -> Optional [ str ]: \"\"\"Return the description for this Agent.\"\"\" if self . _metadata is None : return None description = self . _metadata [ \"description\" ] assert description is None or isinstance ( description , str ) return description @property def queries ( self ) -> Optional [ List [ str ]]: \"\"\"Return the queries for this Agent.\"\"\" if self . _metadata is None : return None queries = self . _metadata [ \"queries\" ] assert queries is None or ( isinstance ( queries , list ) and all ( isinstance ( q , str ) for q in queries ) ) return queries @property def more_info_url ( self ) -> Optional [ str ]: \"\"\"Return the more info URL for this Agent.\"\"\" if self . _metadata is None : return None more_info_url = self . _metadata [ \"moreInfoUrl\" ] assert more_info_url is None or isinstance ( more_info_url , str ) return more_info_url @property def published ( self ) -> Optional [ bool ]: \"\"\"Return the published status for this Agent.\"\"\" if self . _metadata is None : return None published = self . _metadata [ \"published\" ] assert published is None or isinstance ( published , bool ) return published @property def owner ( self ) -> Optional [ str ]: \"\"\"Return the owner of this Agent, which is either a username or an Organization handle.\"\"\" if self . _metadata is None : return None owner_username = self . _metadata [ \"owner\" ] . get ( \"username\" ) or self . _metadata [ \"owner\" ] . get ( \"handle\" ) assert owner_username is None or isinstance ( owner_username , str ) return owner_username @property def query_url ( self ) -> Optional [ str ]: \"\"\"Return the query URL for this Agent.\"\"\" if self . _metadata is None : return None url = self . _metadata [ \"queryUrl\" ] assert url is None or isinstance ( url , str ) return url @property def func_url ( self ) -> Optional [ str ]: \"\"\"Return the func URL for this Agent.\"\"\" if self . _metadata is None : return None url = self . _metadata [ \"funcUrl\" ] assert url is None or isinstance ( url , str ) return url @property def created ( self ) -> Optional [ datetime . datetime ]: \"\"\"Return the creation timestamp for this Agent.\"\"\" if self . _metadata is None : return None ts = self . _metadata [ \"created\" ] if ts is not None : return datetime . datetime . fromisoformat ( ts ) else : return None @property def modified ( self ) -> Optional [ datetime . datetime ]: \"\"\"Return the modification timestamp for this Agent.\"\"\" if self . _metadata is None : return None ts = self . _metadata [ \"modified\" ] if ts is not None : return datetime . datetime . fromisoformat ( ts ) else : return None def get_metadata ( self ) -> Dict [ str , Any ]: \"\"\"Return metadata about this Agent.\"\"\" query = gql ( \"\"\" query getAgentById($agentId: String!) { agentById(agentId: $agentId) { agentId handle name description queries moreInfoUrl published owner { __typename ... on UserType { username } ... on OrganizationType { handle } } queryUrl funcUrl created modified } } \"\"\" ) result = self . _gqlclient . execute ( query , variable_values = { \"agentId\" : f \" { self . _owner } / { self . _handle } \" } ) if \"agentById\" not in result or result [ \"agentById\" ] is None : raise ValueError ( f \"Cannot fetch agent metadata for { self . _owner } / { self . _handle } \" ) agent_dict = result [ \"agentById\" ] assert isinstance ( agent_dict , dict ) and all ( isinstance ( k , str ) for k in agent_dict . keys () ) return agent_dict def create_agent ( self , name : Optional [ str ], description : str , query_url : Optional [ str ] = None , func_url : Optional [ str ] = None , more_info_url : Optional [ str ] = None , published : Optional [ bool ] = None , ) -> str : \"\"\"Create a new Agent with the given parameters.\"\"\" query = gql ( \"\"\" mutation CreateAgent( $handle: String!, $name: String, $description: String!, $queryUrl: String, $funcUrl: String, $moreInfoUrl: String, $published: Boolean) { createAgent( agentData: { handle: $handle, name: $name, description: $description, queryUrl: $queryUrl, funcUrl: $funcUrl, moreInfoUrl: $moreInfoUrl, published: $published } ) { agent { agentId } } } \"\"\" ) variable_values : Dict [ str , Any ] = { \"handle\" : self . _handle } if name is not None : variable_values [ \"name\" ] = name variable_values [ \"description\" ] = description if query_url is not None : variable_values [ \"queryUrl\" ] = query_url if func_url is not None : warnings . warn ( \"Setting func_url via create_agent is deprecated, use FixieClient.create_agent_revision instead.\" ) variable_values [ \"funcUrl\" ] = func_url if more_info_url is not None : variable_values [ \"moreInfoUrl\" ] = more_info_url if published is not None : variable_values [ \"published\" ] = published result = self . _gqlclient . execute ( query , variable_values = variable_values ) if \"createAgent\" not in result or result [ \"createAgent\" ] is None : raise ValueError ( f \"Failed to create Agent\" ) assert isinstance ( result [ \"createAgent\" ], dict ) assert isinstance ( result [ \"createAgent\" ][ \"agent\" ], dict ) assert isinstance ( result [ \"createAgent\" ][ \"agent\" ][ \"agentId\" ], str ) self . _metadata = self . get_metadata () return result [ \"createAgent\" ][ \"agent\" ][ \"agentId\" ] def update_agent ( self , new_handle : Optional [ str ] = None , name : Optional [ str ] = None , description : Optional [ str ] = None , query_url : Optional [ str ] = None , func_url : Optional [ str ] = None , more_info_url : Optional [ str ] = None , published : Optional [ bool ] = None , ) -> str : \"\"\"Update the Agent with the given parameters.\"\"\" query = gql ( \"\"\" mutation UpdateAgent( $handle: String!, $newHandle: String, $name: String, $description: String, $queryUrl: String, $funcUrl: String, $moreInfoUrl: String, $published: Boolean) { updateAgent( agentData: { handle: $handle, newHandle: $newHandle, name: $name, description: $description, queryUrl: $queryUrl, funcUrl: $funcUrl, moreInfoUrl: $moreInfoUrl, published: $published } ) { agent { agentId } } } \"\"\" ) variable_values : Dict [ str , Any ] = { \"handle\" : self . _handle } if new_handle is not None : variable_values [ \"newHandle\" ] = new_handle if name is not None : variable_values [ \"name\" ] = name if description is not None : variable_values [ \"description\" ] = description if query_url is not None : variable_values [ \"queryUrl\" ] = query_url if func_url is not None : warnings . warn ( \"Setting func_url via update_agent is deprecated, use FixieClient.create_agent_revision instead.\" ) variable_values [ \"funcUrl\" ] = func_url if more_info_url is not None : variable_values [ \"moreInfoUrl\" ] = more_info_url if published is not None : variable_values [ \"published\" ] = published result = self . _gqlclient . execute ( query , variable_values = variable_values ) if \"updateAgent\" not in result or result [ \"updateAgent\" ] is None : raise ValueError ( f \"Failed to update Agent\" ) assert isinstance ( result [ \"updateAgent\" ], dict ) assert isinstance ( result [ \"updateAgent\" ][ \"agent\" ], dict ) assert isinstance ( result [ \"updateAgent\" ][ \"agent\" ][ \"agentId\" ], str ) self . _metadata = self . get_metadata () if new_handle : self . _handle = new_handle return result [ \"updateAgent\" ][ \"agent\" ][ \"agentId\" ] def delete_agent ( self ) -> None : \"\"\"Delete this Agent.\"\"\" query = gql ( \"\"\" mutation DeleteAgent($owner: String!, $handle: String!) { deleteAgent(agentData: {owner: $owner, handle: $handle}) { agent { handle } } } \"\"\" ) _ = self . _gqlclient . execute ( query , variable_values = { \"owner\" : self . owner , \"handle\" : self . _handle } )","title":"Agent"},{"location":"python-client-api/#fixieai.client.agent.Agent.agent_id","text":"Return the agentId for this Agent.","title":"agent_id"},{"location":"python-client-api/#fixieai.client.agent.Agent.created","text":"Return the creation timestamp for this Agent.","title":"created"},{"location":"python-client-api/#fixieai.client.agent.Agent.description","text":"Return the description for this Agent.","title":"description"},{"location":"python-client-api/#fixieai.client.agent.Agent.func_url","text":"Return the func URL for this Agent.","title":"func_url"},{"location":"python-client-api/#fixieai.client.agent.Agent.handle","text":"Return the handle for this Agent.","title":"handle"},{"location":"python-client-api/#fixieai.client.agent.Agent.modified","text":"Return the modification timestamp for this Agent.","title":"modified"},{"location":"python-client-api/#fixieai.client.agent.Agent.more_info_url","text":"Return the more info URL for this Agent.","title":"more_info_url"},{"location":"python-client-api/#fixieai.client.agent.Agent.name","text":"Return the name for this Agent.","title":"name"},{"location":"python-client-api/#fixieai.client.agent.Agent.owner","text":"Return the owner of this Agent, which is either a username or an Organization handle.","title":"owner"},{"location":"python-client-api/#fixieai.client.agent.Agent.published","text":"Return the published status for this Agent.","title":"published"},{"location":"python-client-api/#fixieai.client.agent.Agent.queries","text":"Return the queries for this Agent.","title":"queries"},{"location":"python-client-api/#fixieai.client.agent.Agent.query_url","text":"Return the query URL for this Agent.","title":"query_url"},{"location":"python-client-api/#fixieai.client.agent.Agent.valid","text":"Return whether this Agent is valid.","title":"valid"},{"location":"python-client-api/#fixieai.client.agent.Agent.create_agent","text":"Create a new Agent with the given parameters. Source code in fixieai/client/agent.py 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 def create_agent ( self , name : Optional [ str ], description : str , query_url : Optional [ str ] = None , func_url : Optional [ str ] = None , more_info_url : Optional [ str ] = None , published : Optional [ bool ] = None , ) -> str : \"\"\"Create a new Agent with the given parameters.\"\"\" query = gql ( \"\"\" mutation CreateAgent( $handle: String!, $name: String, $description: String!, $queryUrl: String, $funcUrl: String, $moreInfoUrl: String, $published: Boolean) { createAgent( agentData: { handle: $handle, name: $name, description: $description, queryUrl: $queryUrl, funcUrl: $funcUrl, moreInfoUrl: $moreInfoUrl, published: $published } ) { agent { agentId } } } \"\"\" ) variable_values : Dict [ str , Any ] = { \"handle\" : self . _handle } if name is not None : variable_values [ \"name\" ] = name variable_values [ \"description\" ] = description if query_url is not None : variable_values [ \"queryUrl\" ] = query_url if func_url is not None : warnings . warn ( \"Setting func_url via create_agent is deprecated, use FixieClient.create_agent_revision instead.\" ) variable_values [ \"funcUrl\" ] = func_url if more_info_url is not None : variable_values [ \"moreInfoUrl\" ] = more_info_url if published is not None : variable_values [ \"published\" ] = published result = self . _gqlclient . execute ( query , variable_values = variable_values ) if \"createAgent\" not in result or result [ \"createAgent\" ] is None : raise ValueError ( f \"Failed to create Agent\" ) assert isinstance ( result [ \"createAgent\" ], dict ) assert isinstance ( result [ \"createAgent\" ][ \"agent\" ], dict ) assert isinstance ( result [ \"createAgent\" ][ \"agent\" ][ \"agentId\" ], str ) self . _metadata = self . get_metadata () return result [ \"createAgent\" ][ \"agent\" ][ \"agentId\" ]","title":"create_agent()"},{"location":"python-client-api/#fixieai.client.agent.Agent.delete_agent","text":"Delete this Agent. Source code in fixieai/client/agent.py 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 def delete_agent ( self ) -> None : \"\"\"Delete this Agent.\"\"\" query = gql ( \"\"\" mutation DeleteAgent($owner: String!, $handle: String!) { deleteAgent(agentData: {owner: $owner, handle: $handle}) { agent { handle } } } \"\"\" ) _ = self . _gqlclient . execute ( query , variable_values = { \"owner\" : self . owner , \"handle\" : self . _handle } )","title":"delete_agent()"},{"location":"python-client-api/#fixieai.client.agent.Agent.get_metadata","text":"Return metadata about this Agent. Source code in fixieai/client/agent.py 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 def get_metadata ( self ) -> Dict [ str , Any ]: \"\"\"Return metadata about this Agent.\"\"\" query = gql ( \"\"\" query getAgentById($agentId: String!) { agentById(agentId: $agentId) { agentId handle name description queries moreInfoUrl published owner { __typename ... on UserType { username } ... on OrganizationType { handle } } queryUrl funcUrl created modified } } \"\"\" ) result = self . _gqlclient . execute ( query , variable_values = { \"agentId\" : f \" { self . _owner } / { self . _handle } \" } ) if \"agentById\" not in result or result [ \"agentById\" ] is None : raise ValueError ( f \"Cannot fetch agent metadata for { self . _owner } / { self . _handle } \" ) agent_dict = result [ \"agentById\" ] assert isinstance ( agent_dict , dict ) and all ( isinstance ( k , str ) for k in agent_dict . keys () ) return agent_dict","title":"get_metadata()"},{"location":"python-client-api/#fixieai.client.agent.Agent.update_agent","text":"Update the Agent with the given parameters. Source code in fixieai/client/agent.py 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 def update_agent ( self , new_handle : Optional [ str ] = None , name : Optional [ str ] = None , description : Optional [ str ] = None , query_url : Optional [ str ] = None , func_url : Optional [ str ] = None , more_info_url : Optional [ str ] = None , published : Optional [ bool ] = None , ) -> str : \"\"\"Update the Agent with the given parameters.\"\"\" query = gql ( \"\"\" mutation UpdateAgent( $handle: String!, $newHandle: String, $name: String, $description: String, $queryUrl: String, $funcUrl: String, $moreInfoUrl: String, $published: Boolean) { updateAgent( agentData: { handle: $handle, newHandle: $newHandle, name: $name, description: $description, queryUrl: $queryUrl, funcUrl: $funcUrl, moreInfoUrl: $moreInfoUrl, published: $published } ) { agent { agentId } } } \"\"\" ) variable_values : Dict [ str , Any ] = { \"handle\" : self . _handle } if new_handle is not None : variable_values [ \"newHandle\" ] = new_handle if name is not None : variable_values [ \"name\" ] = name if description is not None : variable_values [ \"description\" ] = description if query_url is not None : variable_values [ \"queryUrl\" ] = query_url if func_url is not None : warnings . warn ( \"Setting func_url via update_agent is deprecated, use FixieClient.create_agent_revision instead.\" ) variable_values [ \"funcUrl\" ] = func_url if more_info_url is not None : variable_values [ \"moreInfoUrl\" ] = more_info_url if published is not None : variable_values [ \"published\" ] = published result = self . _gqlclient . execute ( query , variable_values = variable_values ) if \"updateAgent\" not in result or result [ \"updateAgent\" ] is None : raise ValueError ( f \"Failed to update Agent\" ) assert isinstance ( result [ \"updateAgent\" ], dict ) assert isinstance ( result [ \"updateAgent\" ][ \"agent\" ], dict ) assert isinstance ( result [ \"updateAgent\" ][ \"agent\" ][ \"agentId\" ], str ) self . _metadata = self . get_metadata () if new_handle : self . _handle = new_handle return result [ \"updateAgent\" ][ \"agent\" ][ \"agentId\" ]","title":"update_agent()"},{"location":"python-client-api/#fixieai.cli.cli.fixie","text":"Command-line interface to the Fixie platform. Source code in fixieai/cli/cli.py 37 38 39 40 41 @click . group () @click . pass_context def fixie ( ctx ): \"\"\"Command-line interface to the Fixie platform.\"\"\" ctx . ensure_object ( CliContext )","title":"fixie()"},{"location":"python-client-api/#fixieai.cli.session.console.Console","text":"A simple console interface for Fixie. Source code in fixieai/cli/session/console.py 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 class Console : \"\"\"A simple console interface for Fixie.\"\"\" def __init__ ( self , client : FixieClient , session : Session , history_file : str = HISTORY_FILE , ): self . _client = client self . _session = session history_file = os . path . expanduser ( history_file ) os . makedirs ( os . path . dirname ( history_file ), exist_ok = True ) self . _history_file = history_file self . _response_index = 0 def run ( self , initial_message : Optional [ str ] = None , ) -> None : \"\"\"Run the console application.\"\"\" textconsole . print ( \"[blue]Welcome to Fixie!\" ) textconsole . print ( f \"Connected to: { self . _session . session_url } \" ) # Show what's already in the session thus far. for message in self . _session . get_messages (): self . _show_message ( message , show_user_message = True ) history = prompt_toolkit . history . FileHistory ( self . _history_file ) if initial_message : prompt_toolkit . print_formatted_text ( f \" { PROMPT }{ initial_message } \" ) history . append_string ( initial_message ) self . _query ( initial_message ) while True : in_text = prompt_toolkit . prompt ( PROMPT , history = history , auto_suggest = prompt_toolkit . auto_suggest . AutoSuggestFromHistory (), ) self . _query ( in_text ) def _query ( self , in_text : str ) -> None : try : self . _response_index += 1 print ( f \" { self . _response_index } \u276f \" , end = \"\" ) pos = 0 sys . stdout . flush () for message in self . _session . streaming_query ( in_text ): text = message [ \"text\" ][ pos :] textconsole . print ( text , end = \"\" ) sys . stdout . flush () pos += len ( text ) print ( \"\" ) self . _show_embeds ( message [ \"text\" ]) except requests . exceptions . HTTPError as e : textconsole . print ( f \"\ud83d\udea8 { e } \" ) return def _show_message ( self , message : Dict [ str , Any ], show_user_message : bool = False ): \"\"\"Shows a message dict from FixieClient. If show_user_message is set, the user messages are also printed with the PROMPT. This option is useful for showing previous messages in the chat when connecting to a session. \"\"\" sender_handle = ( message [ \"sentBy\" ][ \"handle\" ] if message . get ( \"sentBy\" ) else \"<unknown>\" ) message_text = message [ \"text\" ] if message [ \"type\" ] == \"query\" and sender_handle == \"user\" : if show_user_message : textconsole . print ( markdown . Markdown ( PROMPT + message_text )) elif message [ \"type\" ] != \"response\" : textconsole . print ( markdown . Markdown ( f \" @ { sender_handle } : \" + message_text , style = \"dim\" ) ) else : self . _response_index += 1 textconsole . print ( markdown . Markdown ( f \" { self . _response_index } \u276f \" + message_text ) ) self . _show_embeds ( message [ \"text\" ]) def _show_embeds ( self , message : str ): \"\"\"Shows embeds referenced in `message_text`.\"\"\" # Check embed references in message (denoted by #id). embed_ids = _extract_embed_refs ( message ) if not embed_ids : return # Get a dict of all embed_id -> embeds in the session. embeds = { embed_dict [ \"key\" ]: embed_dict [ \"embed\" ] for embed_dict in self . _session . get_embeds () } # Show what we can find. for embed_id in embed_ids : if embed_id not in embeds : textconsole . print ( f \" [dim]embed # { embed_id } not found in session[/]\" , style = \"red\" ) continue _show_embed ( embeds [ embed_id ][ \"url\" ], embeds [ embed_id ][ \"contentType\" ], )","title":"Console"},{"location":"python-client-api/#fixieai.cli.session.console.Console.run","text":"Run the console application. Source code in fixieai/cli/session/console.py 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 def run ( self , initial_message : Optional [ str ] = None , ) -> None : \"\"\"Run the console application.\"\"\" textconsole . print ( \"[blue]Welcome to Fixie!\" ) textconsole . print ( f \"Connected to: { self . _session . session_url } \" ) # Show what's already in the session thus far. for message in self . _session . get_messages (): self . _show_message ( message , show_user_message = True ) history = prompt_toolkit . history . FileHistory ( self . _history_file ) if initial_message : prompt_toolkit . print_formatted_text ( f \" { PROMPT }{ initial_message } \" ) history . append_string ( initial_message ) self . _query ( initial_message ) while True : in_text = prompt_toolkit . prompt ( PROMPT , history = history , auto_suggest = prompt_toolkit . auto_suggest . AutoSuggestFromHistory (), ) self . _query ( in_text )","title":"run()"}]}